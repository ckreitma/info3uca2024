<!DOCTYPE html>
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Introduction to Computer Graphics, Section 7.1 -- Transformations in 3D</title>
<link type="text/css" rel="stylesheet" href="../resource/graphicstext.css">
</head>
<body>
<div class="page">
<div align="right">
<small>
        [  <a href="s2.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
	    <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" cellpadding="5" border="2">
<tr>
<td>
<div align="center">
<b>Subsections</b>
<hr>
<small><a href="#webgl3d.1.1">About Shader Scripts</a>
<br>
<a href="#webgl3d.1.2">Introducing glMatrix</a>
<br>
<a href="#webgl3d.1.3">Transforming Coordinates</a>
<br>
<a href="#webgl3d.1.4">Transforming Normals</a>
<br>
<a href="#webgl3d.1.5">Rotation by Mouse</a>
<br>
</small>
</div>
</td>
</tr>
</table>
<div class="content section">
<h3 class="section_title">Section 7.1</h3>
<h2 class="section_title">Transformations in 3D</h2>
<hr class="break">


<p class="firstpar">We have already seen in <a href="../c6/index.html">Chapter&nbsp;6</a> how to draw <span class="word" data-term="geometric primitive" data-definition="Geometric objects in a graphics system, such as OpenGL, that are
not made up of simpler objects.  Examples in OpenGL include points, lines, and triangles,
but the set of available primitives depends on the graphics system.  (Note that as the term
is used in OpenGL, a single primitive can be made up of many points, line segments, or triangles.)" title="Click for a definition of geometric primitive.">primitives</span>
using WebGL, and how to implement 2D transformations.  Drawing primitives is the same in 3D,
except that there are three coordinates per vertex instead of two.  Transformations in 3D are also
 similar
to 2D, but for transformations the increase in complexity that comes with the third dimension is
substantial.  This section covers the geometric side of 3D graphics with WebGL.  In the
<a href="../c7/s2.html">next section</a>, we will move on to the question of 
lighting and materials.</p>


<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl3d.1.1">7.1.1&nbsp;&nbsp;About Shader Scripts</h3>


<p>But before we begin working more seriously with WebGL, it will be nice to have a better
way to include shader source code on a web page.  Up until now, I have created the source code
strings by concatenating a bunch of JavaScript string literals, one for each line of code.
That format is hard to read and very hard to edit.
There are at least two other techniques that are often used. One is to put the GLSL shader source code inside
<span class="tag">&lt;script&gt;</span> elements.  Here is an example for a vertex shader:</p>


<pre>&lt;script type="x-shader/x-vertex" id="vshader"&gt;
    attribute vec3 a_coords;
    uniform mat4 modelviewProjection;
    void main() {
        vec4 coords = vec4(a_coords,1.0);
        gl_Position = modelviewProjection * coords;
    }
&lt;/script&gt;</pre>


<p class="noindent">This relies on the fact that a web browser will not recognize the <i>type</i> listed in
the <span class="tag">&lt;script&gt;</span> element, so it will not try to execute the script.  However,
it does store the content of the <span class="tag">&lt;script&gt;</span> element in the <span class="word" data-term="DOM" data-definition="Document Object Model.  A specification for representing a web page (and other kinds of
structured document) as a tree-like data structure.  Can also refer to the data structure itself,
as in &quot;the DOM for this web page.&quot;  A web page can be modified dynamically by manipulating its
DOM, using the JavaScript programming language." title="Click for a definition of DOM.">DOM</span> data structure that
represents the web page.  The content can be retrieved as a string using the standard 
DOM API.  I won't explain the API functions that are used, but
here is a function that takes the <i>id</i> of the script element as its parameter and returns a
string containing the text from inside the element:
</p>


<pre>function getTextContent( elementID ) {
    let element = document.getElementById(elementID);
    let node = element.firstChild;
    let str = "";
    while (node) {
        if (node.nodeType == 3) // this is a text node
            str += node.textContent;
        node = node.nextSibling;
    }
    return str;
}</pre>


<p class="noindent">The sample program <span class="sourceref"><a href="../source/webgl/glmatrix-cube-unlit.html">webgl/glmatrix-cube-unlit.html</a></span> uses this
technique.  The other idea is to define the source code as a JavaScript template string.
(See <a href="../a1/s3.html#proglang.3.1">Subsection&nbsp;A.3.1</a>).
A template string is enclosed between single backquote characters and can span
multiple lines.  (The "backquote" is also called a "backtick.")
Template strings were only introduced into JavaScript as part of
<span class="word" data-term="ES6" data-definition="A version of JavaScript implemented by almost all modern web browsers.  More formally
known as ECMAScript&nbsp;6 or ECMAScript&nbsp;2015.  ES6 introduced a large number of new features." title="Click for a definition of ES6.">ES6</span>.  They can include the values of JavaScript expressions,
but we don't need that capability here.  Here is how the above shader could
be defined as a template string:</p>


<pre>const vertexShaderSource = `
attribute vec3 a_coords;
uniform mat4 modelviewProjection;
void main() {
    vec4 coords = vec4(a_coords,1.0);
    gl_Position = modelviewProjection * coords;
}`;</pre>


<p class="noindent">This technique is used in many of the sample programs in this chapter.
Note that if you define a GLSL&nbsp;ES&nbsp;3.00 shader as a template string,
you should be sure to include the required first line, #version&nbsp;3.00&nbsp;es,
immediately after the opening backquote, since that line cannot be preceded
by a blank line.</p>


</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl3d.1.2">7.1.2&nbsp;&nbsp;Introducing glMatrix</h3>


<p>Transformations are essential to computer graphics.  The WebGL API does not 
provide any functions for working with transformations.  In <a href="../c6/s5.html">Section&nbsp;6.5</a>,
we used a simple JavaScript class to represent modeling transformations in 2D.
Things get more complex in three dimensions.  For 3D graphics with WebGL,
the JavaScript side will usually have to create both a <span class="word" data-term="modelview transformation" data-definition="In OpenGL 1.1, a transform that combines the
modeling transform with the viewing transform.  That is, it is the composition of
the transformation from object coordinates to world coordinates and the transformation
from world coordinates to eye coordinates.  Because of the equivalence between
modeling and viewing transformations, world coordinates are not really meaningful for
OpenGL, and only the combined transformation is tracked." title="Click for a definition of modelview transformation.">modelview transform</span>
and a <span class="word" data-term="projection transformation" data-definition="In 3D graphics, a transformation that maps
a scene in 3D space onto a 2D image.  In OpenGL 1.1, the projection maps the view
volume (that is, the region in 3D space that is visible in the image) 
to clip coordinates, in which the values of x, y, and z range from -1 to 1.
The x- and y-coordinates are then mapped to the image, while the z coordinate provides
depth information." title="Click for a definition of projection transformation.">projection transform</span>, and it will have to apply rotation, scaling, and
translation to the modelview matrix, all without help from WebGL.  Doing so is much
easier if you have a JavaScript library to do the work.  One commonly used library
is <span class="newword" data-term="glMatrix" data-definition="An open-source JavaScript library for vector and matrix math in
two and three dimensions." title="Click for a definition of glMatrix.">glMatrix</span>, a free JavaScript library for vector and
matrix math written by Brandon Jones and Colin MacKenzie IV.  It
is available from <a href="https://glmatrix.net">https://glmatrix.net</a>.
This textbook uses Version&nbsp;2.3 of the library, from 2015, although newer
versions are available. According to its license,
this file can be freely used and distributed. My programs use
the script <i>gl-matrix-min.js</i>. You can find a copy in the
<i>source</i> folder in the web site download of this book. This file
is a "minified" JavaScript file, which is not meant to be human-readable.
(You can also read the full source for version 2.2, in
human-readable form including comments, in the file <span class="sourceref"><a href="../source/webgl/gl-matrix.js">webgl/gl-matrix.js</a></span>,
and more information can be found on the glmatrix web site.)</p>


<p>The <i>glMatrix</i> API can be made available for use
on a web page with a script element such as</p>


<pre>&lt;script src="gl-matrix-min.js"&gt;&lt;/script&gt;</pre>


<p class="noindent">This assumes that <i>gl-matrix-min.js</i> is in the same directory as
the web page.</p>



<p>The <i>glMatrix</i> library defines what it calls "classes" named <span class="classname">vec2</span>, <span class="classname">vec3</span>, and <span class="classname">vec4</span>
for working with vectors of 2, 3, and 4 numbers.  It defines <span class="classname">mat3</span> for working with
3-by-3 matrices and <span class="classname">mat4</span> for 4-by-4 matrices.  The names should not be confused
with the <span class="word" data-term="GLSL" data-definition="OpenGL Shader Language, the programming language that is used to write
shader programs for use with OpenGL." title="Click for a definition of GLSL.">GLSL</span> types of the same names; <i>glMatrix</i> in entirely on the JavaScript side.
However, a <i>glMatrix</i> <span class="classname">mat4</span> can be passed to a <span class="word" data-term="shader" data-definition="A program to be executed at some stage of the rendering pipeline.  OpenGL
shaders are written in the GLSL programming languages.  For WebGL, only vertex shaders
and fragment shaders are supported.  WebGPU also has compute shaders, which are used
in compute pipelines." title="Click for a definition of shader.">shader</span> program
to specify the value of a GLSL <i>mat4</i>, and similarly for the other vector and matrix types.
</p>


<p>Each <i>glMatrix</i> class defines a set of functions for working with vectors and matrices.
In fact, however, although the documentation uses the term "class,"
<i>glMatrix</i> is not object-oriented.  Its classes are really just JavaScript objects, 
and the functions in its classes are what would be called static methods in Java.  Vectors and matrices
are represented in <i>glMatrix</i> as arrays, and the functions in classes like <span class="classname">vec4</span>
and <span class="classname">mat4</span> simply operate on those arrays.  There are no objects of type
<span class="classname">vec4</span> or <span class="classname">mat4</span> as such, just arrays of length 4 or 16 respectively.
The arrays can be either ordinary JavaScript arrays or <span class="word" data-term="typed array" data-definition="In JavaScript, an array type that is limited to holding numerical values
of a single type.  For example, the type Float32Array represents arrays that can hold 32-bit floating
point values, and Uint8Array arrays can hold only 8-bit integer values.  Such arrays are more efficient
than general JavaScript arrays for numerical calculations.  The were introduced into JavaScript
along with HTML canvas graphics and WebGL." title="Click for a definition of typed array.">typed arrays</span>
of type <span class="classname">Float32Array</span>.  If you let <i>glMatrix</i> create the
arrays for you, they will be <span class="classname">Float32Arrays</span>, but all <i>glMatrix</i>
functions will work with either kind of array.  For example, if the <i>glMatrix</i> documentation
says that a parameter should be of type <span class="classname">vec3</span>, it is OK to pass either a <span class="classname">Float32Array</span>
or a regular JavaScript array of three numbers as the value of that parameter.</p>


<p>Note that it is also the case
that either kind of array can be used in WebGL functions such as <i>gl.uniform3fv</i>()
and <i>gl.uniformMatrix4fv</i>().  <i>glMatrix</i> is designed to work with those functions.
For example, a <span class="classname">mat4</span> in <i>glMatrix</i> is an array of length 16 that holds the
elements of a 4-by-4 array in <span class="word" data-term="column-major order" data-definition="Column-by-column ordering of the elements of a two-dimensional
matrix; that is, an ordering that starts with the elements in the first column,
followed by the elements in the second column, and so on.  Column-major order is used for
matrices in OpenGL and GLSL." title="Click for a definition of column-major order.">column-major order</span>, the same format that
is used by <i>gl.uniformMatrix4fv</i>.</p>


<hr class="break">


<p>Each <i>glMatrix</i> class has a <i>create</i>() function which creates an array of
the appropriate length and fills it with default values.  For example,</p>


<pre>transform = mat4.create();</pre>


<p class="noindent">sets <i>transform</i> to be a new <span class="classname">Float32Array</span> of length 16,
initialized to represent the identity matrix.  Similarly,</p>


<pre>vector = vec3.create();</pre>


<p class="noindent">creates a <span class="classname">Float32Array</span>  of length 3, filled with
zeros.  Each class also has a function <i>clone</i>(<i>x</i>) that creates a copy of its
parameter&nbsp;<i>x</i>.  For example:</p>


<pre>saveTransform = mat4.clone(modelview);</pre>


<p>Most other functions do <b>not</b> create new arrays.  Instead, they modify the contents of their
first parameter.  For example, <i>mat4.multiply</i>(<i>A,B,C</i>) will modify <i>A</i> so that
it holds the matrix product of <i>B</i> and <i>C</i>.  Each parameter must be a <span class="classname">mat4</span>
(that is, an array of length 16) that already exists.  It is OK for some of the arrays
to be the same.  For example, <i>mat4.multiply</i>(<i>A,A,B</i>) has the effect of
multiplying <i>A</i> times <i>B</i> and modifying <i>A</i> so that it contains the answer.</p>


<p>There are functions for multiplying a matrix by standard transformations such as
scaling and rotation.  For example if <i>A</i> and <i>B</i> are <span class="classname">mat4s</span> and <i>v</i> is a 
<span class="classname">vec3</span>,
then <i>mat4.translate</i>(<i>A,B,v</i>) makes <i>A</i> equal to the product of <i>B</i> and
the matrix that represents translation by the vector&nbsp;<i>v</i>.  In practice, we will
use such operations mostly on a matrix that represents the modelview transformation.
So, suppose that we have a <span class="classname">mat4</span> named <i>modelview</i> that holds the current modelview
transform.  To apply a translation by a vector <span class="code">[dx,dy,dz]</span>, we can say</p>


<pre>mat4.translate( modelview, modelview, [dx,dy,dz] );</pre>


<p class="noindent">This is equivalent to calling <i>glTranslatef</i>(<i>dx,dy,dz</i>) in
OpenGL.  That is, if we draw some geometry after this statement, using <i>modelview</i>
as the modelview transformation, then the geometry will first be translated by
<span class="code">[dx,dy,dz]</span> and then will be transformed by whatever was the previous value
of <i>modelview</i>.  Note the use of a vector to specify the translation in this
command, rather than three separate parameters; this is typical of <i>glMatrix</i>.
To apply a scaling transformation with scale factors <i>sx</i>, <i>sy</i>, and <i>sz</i>,
use</p>


<pre>mat4.scale( modelview, modelview, [sx,sy,sz] );</pre>


<p class="noindent">For rotation, <i>glMatrix</i> has four functions, including three for the common
cases of rotation about the <i>x</i>, <i>y</i>, or <i>z</i> axis.  The fourth rotation function
specifies the axis of rotation as the line from (0,0,0) to a point (<i>dx,dy,dz</i>).
This is equivalent to <i>glRotatef(angle,dx,dy,dz)</i>
Unfortunately, the angle of rotation in these functions
is specified in radians rather than in degrees:</p>


<pre>mat4.rotateX( modelview, modelview, radians );
mat4.rotateY( modelview, modelview, radians );
mat4.rotateZ( modelview, modelview, radians );
mat4.rotate( modelview, modelview, radians, [dx,dy,dz] );</pre>


<p>These functions allow us to do all the basic modeling and viewing transformations that we
need for 3D graphics.  To do hierarchical graphics, we also need to save and restore the
transformation as we traverse the scene graph.  For that, we need a stack. We
can use a regular JavaScript array, which already has <i>push</i> and <i>pop</i> operations.  
So, we can create the stack as an empty array:</p>


<pre>const matrixStack = [];</pre>


<p class="noindent">We can then push a copy of the current modelview matrix onto the stack by saying</p>


<pre>matrixStack.push( mat4.clone(modelview) );</pre>


<p class="noindent">and we can remove a matrix from the stack and set it to be the current modelview matrix with</p>


<pre>modelview = matrixStack.pop();</pre>


<p class="noindent">These operations are equivalent to <i>glPushMatrix</i>() and <i>glPopMatrix</i>()
in OpenGL.</p>


<hr class="break">


<p>The starting point for the modelview transform is usually a <span class="word" data-term="viewing transformation" data-definition="The transformation in 3D graphics that maps world
coordinates to eye coordinates.  The viewing transform establishes the position, orientation,
and scale of the viewer in the world." title="Click for a definition of viewing transformation.">viewing transform</span>.
In OpenGL, the function <i>gluLookAt</i> is often used to set up the viewing transformation  
(<a href="../c3/s3.html#gl1geom.3.4">Subsection&nbsp;3.3.4</a>).  The <i>glMatrix</i> library has a "lookAt" function to do the same thing:</p>


<pre>mat4.lookAt( modelview, [eyex,eyey,eyez], [refx,refy,refz], [upx,upy,upz] );</pre>


<p class="noindent">Note that this function uses three <span class="classname">vec3's</span> in place of the nine separate parameters
in <i>gluLookAt</i>, and it places the result in its first parameter instead of in a global variable.
This function call is actually equivalent to the two OpenGL commands</p>


<pre>glLoadIdentity();
gluLookAt( eyex,eyey,eyez,refx,refy,refz,upx,upy,upz );</pre>


<p class="noindent">So, you don't have to set <i>modelview</i> equal to the identity matrix before calling
<i>mat4.lookAt</i>, as you would usually do in OpenGL.  However, you do have to create
the <i>modelview</i> matrix at some point before using <i>mat4.lookAt</i>, such as by calling</p>


<pre>let modelview = mat4.create();</pre>


<p class="noindent">If you do want to set an existing <span class="classname">mat4</span> to the identity matrix,
you can do so with the <i>mat4.identity</i> function.  For example,</p>


<pre>mat4.identity( modelview );</pre>


<p class="noindent">You could use this as a starting point if you wanted to compose the view transformation out of
basic scale, rotate, and translate transformations.</p>


<p>Similarly, <i>glMatrix</i> has functions for setting up projection transformations.
It has functions equivalent to <i>glOrtho</i>, <i>glFrustum</i>, and <i>gluPerspective</i>
(<a href="../c3/s3.html#gl1geom.3.3">Subsection&nbsp;3.3.3</a>),
except that the field-of-view angle in <i>mat4.perspective</i> is given in radians rather
than degrees:</p>


<pre>mat4.ortho( projection, left, right, bottom, top, near, far );

mat4.frustum( projection, left, right, bottom, top, near, far );

mat4.perspective( projection, fovyInRadians, aspect, near, far );</pre>


<p class="noindent">As with the modelview transformation, you do not need to load <i>projection</i> with the identity before calling one
of these functions, but you must create <i>projection</i> as a <span class="classname">mat4</span> (or an array of length 16).</p>


</div>


<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl3d.1.3">7.1.3&nbsp;&nbsp;Transforming Coordinates</h3>


<p>Of course, the point of making a projection and a modelview transformation is to use
them to transform coordinates while drawing primitives.  In WebGL, the transformation
is usually done in the vertex shader.  The coordinates for a primitive are specified
in <span class="word" data-term="object coordinates" data-definition="The coordinate system in which the coordinates for points in an 
object are originally specified, before they are transformed by any modeling or other transform that
will be applied to the object." title="Click for a definition of object coordinates.">object coordinates</span>.  They are multiplied by the modelview transformation
to covert them into <span class="word" data-term="eye coordinates" data-definition="The coordinate system on 3D space defined by the viewer.
In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the
direction of the negative z-axis, with the positive y-axis pointing upwards, and the
positive x-axis pointing to the right. The modelview transformation maps objects into
the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates." title="Click for a definition of eye coordinates.">eye coordinates</span> and then by the projection matrix
to covert them to the final <span class="word" data-term="clip coordinates" data-definition="The default coordinate system in OpenGL.  The projection transform
maps the 3D scene to clip coordinates.  The rendered image will show the contents of the
cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything
outside that range is &quot;clipped&quot; away." title="Click for a definition of clip coordinates.">clip coordinates</span> that are actually used for
drawing the primitive.  Alternatively, the modelview and projection matrices can
be multiplied together to get a matrix that represents the combined transformation;
object coordinates can then be multiplied by that matrix to transform them
directly into clip coordinates.</p>


<p>In the shader program, coordinate transforms are usually represented as
GLSL <span class="word" data-term="uniform variable" data-definition="Variables that represent input to a shader program in a
programmable graphics pipeline.  A uniform variable has the same value at every vertex
and at every pixel of a primitive." title="Click for a definition of uniform variable.">uniform variables</span> of type <span class="classname">mat4</span>.
The shader program can use either separate projection and modelview matrices or
a combined matrix (or both).  Sometimes, a separate modelview transform matrix is
required, because certain lighting calculations are done in eye coordinates,
but here is a minimal GLSL&nbsp;ES&nbsp;1.00 vertex shader that uses a combined matrix:</p>


<pre>attribute vec3 a_coords;           // (x,y,z) object coordinates of vertex.
uniform mat4 modelviewProjection;  // Combined transformation matrix.
void main() {
    vec4 coords = vec4(a_coords,1.0);   // Add 1.0 for the w-coordinate.
    gl_Position = modelviewProjection * coords;  // Transform the coordinates.
}</pre>


<p class="noindent">This shader is from the sample program <span class="sourceref"><a href="../source/webgl/glmatrix-cube-unlit.html">webgl/glmatrix-cube-unlit.html</a></span>.
That program lets the user view a colored cube, using just basic color with no lighting applied.
The user can select either an orthographic or a perspective projection and can rotate the
cube using the keyboard.  The rotation is applied as a modeling transformation consisting
of separate rotations about the <i>x</i>-, <i>y</i>-, and <i>z</i>-axes. 
For transformation matrices on 
the JavaScript side, the program uses the <span class="classname">mat4</span> class from the <i>glMatrix</i> library
to represent the projection, modelview, and combined transformation matrices:</p>


<pre>const projection = mat4.create();  // projection matrix
const modelview = mat4.create();   // modelview matrix
const modelviewProjection = mat4.create();  // combined matrix</pre>


<p class="noindent">(These variables can be <i>const</i> since the same matrix objects will be used throughout
the program, even though the numbers in the objects will change.)
Only <i>modelviewProjection</i> corresponds to a shader variable.  The location of
that variable in the shader program is obtained during initialization using</p>


<pre>u_modelviewProjection = gl.getUniformLocation(prog, "modelviewProjection");</pre>


<p class="noindent">The transformation matrices are computed in the <i>draw</i>() function, using
functions from the <i>glMatrix</i> <span class="classname">mat4</span> class.  The
value for <i>modelviewProjection</i> is sent to the shader program using
<i>gl.uniformMatrix4fv</i> before the primitives that make up the cube are drawn.
Here is the code that does it:</p>


<pre>/* Set the value of projection to represent the projection transformation */

if (document.getElementById("persproj").checked) {
     mat4.perspective(projection, Math.PI/5, 1, 4, 8);
}
else {
     mat4.ortho(projection, -2, 2, -2, 2, 4, 8);
}

/* Set the value of modelview to represent the viewing transform. */

mat4.lookAt(modelview, [2,2,6], [0,0,0], [0,1,0]);

/* Apply the modeling transformation to modelview. */

mat4.rotateX(modelview, modelview, rotateX);
mat4.rotateY(modelview, modelview, rotateY);
mat4.rotateZ(modelview, modelview, rotateZ);

/* Multiply the projection matrix times the modelview matrix to give the
   combined transformation matrix, and send that to the shader program. */
   
mat4.multiply( modelviewProjection, projection, modelview );
gl.uniformMatrix4fv(u_modelviewProjection, false, modelviewProjection );</pre>


<p>If separate modelview and projection matrices are used in the shader program,
then the modelview matrix can be applied to transform object coordinates to
eye coordinates, and the projection can then be applied to the eye coordinates
to compute <i>gl_Position</i>.  Here is a minimal vertex shader that does that:</p>


<pre>attribute vec3 a_coords;  // (x,y,z) object coordinates of vertex.
uniform mat4 modelview;   // Modelview transformation.
uniform mat4 projection;  // Projection transformation
void main() {
    vec4 coords = vec4(a_coords,1.0);      // Add 1.0 for w-coordinate.
    vec4 eyeCoords = modelview * coords;   // Apply modelview transform.
    gl_Position = projection * eyeCoords;  // Apply projection transform.
}</pre>


</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl3d.1.4">7.1.4&nbsp;&nbsp;Transforming Normals</h3>


<p>
<span class="word" data-term="normal vector" data-definition="A normal vector to a surface at a point on that 
surface is a vector that is perpendicular to the surface at that point.
Normal vectors to curves are defined similarly.  Normal vectors are important
for lighting calculations." title="Click for a definition of normal vector.">Normal vectors</span> are essential for 
lighting calculations (<a href="../c4/s1.html#gl1light.1.3">Subsection&nbsp;4.1.3</a>).  When a surface
is transformed in some way, it seems that the normal vectors to that
surface will also change.  However, that is not true if the transformation is a translation.
A normal vector tells what direction a surface is facing.  Translating
the surface does not change the direction in which the surface is facing, so
the normal vector remains the same.
Remember that a vector doesn't have a position, just a length and
a direction.  So it doesn't even make sense to talk about moving or
translating a vector.</p>


<p>Your first guess might be that the normal vector should be transformed
by just the rotation/scaling part of the transformation.  The guess is that 
the correct transformation is represented by the 3-by-3 matrix that is
obtained by dropping the right column and the bottom row
from the 4-by-4 coordinate transformation matrix. 
(The right column represents the translation part of the transformation,
and the bottom row is only there because implementing translation in a matrix
requires the use of <span class="word" data-term="homogeneous coordinates" data-definition="A way of representing n-dimensional vectors as
(n+1)-dimensional vectors where two (n+1) vectors represent the same n-dimensional vector
if they differ by a scalar multiple.  In 3D, for example, if w is not zero, then the
homogeneous coordinates (x,y,z,w) are equivalent to homogeneous coordinates 
(x/w,y/w,z/w,1), since they differ by
multiplication by the scalar w.  Both sets of coordinates represent the 3D vector (x/w,y/w,z/w)" title="Click for a definition of homogeneous coordinates.">homogeneous coordinates</span> to represent vectors.
Normal vectors, where translation is not an issue, do not use homogeneous coordinates.)
But that can't be correct in all cases.  Consider, for example, a <span class="word" data-term="shear transform" data-definition="A shear transformation in 2D leaves some line, L, fixed, and lines perpendicular
to L are &quot;tilted&quot; relative to L by the same angle.  Another description is that a line parallel to L is
mapped to itself, but is moved by an amount proportional to its distance from L.  In 3D, a shear
transformation leaves some plane, P, fixed, and it maps a plane parallel to P to itself, but
moved by an amount proportional to its distance from P." title="Click for a definition of shear transform.">shear transform</span>.
As this illustration shows, if the normal vectors to an object are subjected
to the same shear transformation as the object, the resulting vectors
will not be perpendicular to the object:</p>


<p align="center">
<img src="normal-transform.png" width="488" height="168" alt=""></p>


<p>Nevertheless, it is possible to get the correct transformation matrix for normal
vectors from the coordinate transformation matrix.  It turns out that you need to
drop the fourth row and the fourth column and then take something called the
"inverse transpose" of the resulting 3-by-3 matrix.  You don't need to know
what that means or why it works. The <i>glMatrix</i> library will compute it
for you.  The function that you need is <i>normalFromMat4</i>, and it is
defined in the <span class="classname">mat3</span> class:</p>


<pre>mat3.normalFromMat4( normalMatrix, coordinateMatrix );</pre>


<p class="noindent">In this function call, <i>coordinateMatrix</i> is the <span class="classname">mat4</span> that
represents the transformation that is applied to coordinates, and <i>normalMatrix</i> is
a <span class="classname">mat3</span> that already exists.  This function computes the inverse transpose
of the rotation/scale part of <i>coordinateMatrix</i> and places the answer in
<i>normalMatrix</i>.  Since we need normal vectors for lighting calculations, and
lighting calculations are done in eye coordinates, the coordinate transformation that
we are interested in is usually the modelview transform.</p>


<p>The normal matrix should be sent to the shader program, where it is needed to
transform normal vectors for use in lighting calculations.  Lighting requires unit
normal vectors, that is, normal vectors of length one.  The normal matrix does not
in general preserve the length of a vector to which it is applied, so it will
be necessary to normalize the transformed vector.  GLSL has a built-in function for
normalizing vectors.  A vertex shader that implements lighting might take the form:</p>


<pre>attribute vec3 a_coords;   // Untransformed object coordinates.
attribute vec3 normal;     // Normal vector.
uniform mat4 projection;   // Projection transformation matrix.
uniform mat4 modelview;    // Modelview transformation matrix.
uniform mat3 normalMatrix; // Transform matrix for normal vectors.
  .
  .  // Variables to define light and material properties.
  .
void main() {
    vec4 coords = vec4(a_coords,1.0);  // Add a 1.0 for the w-coordinate.
    vec4 eyeCoords = modelview * coords;  // Transform to eye coordinates.
    gl_Position = projection * eyeCoords;  // Transform to clip coordinates.
    vec3 transformedNormal = normalMatrix*normal;  // Transform normal vector.
    vec3 unitNormal = normalize(transformedNormal);  // Normalize.
       .
       .  // Use eyeCoords, unitNormal, and light and material
       .  // properties to compute a color for the vertex.
       .
}</pre>


<p class="noindent">We will look at several specific examples in the <a href="../c7/s2.html">next section</a>.</p>


<p>I will note that GLSL&nbsp;ES&nbsp;3.00 (but not GLSL&nbsp;ES&nbsp;1.00)
has built-in functions for computing the
inverse and the transpose of a matrix, making it fairly easy to compute the normal matrix
in the shader.  However, it might still be more efficient to compute the matrix
once on the JavaScript side, rather than computing it in every execution of the
vertex shader.</p>


</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl3d.1.5">7.1.5&nbsp;&nbsp;Rotation by Mouse</h3>


<p>Computer graphics is a lot more interesting when there is user interaction.  The 3D
experience is enhanced considerably just by letting the user rotate the scene, to view
it from various directions.  The <span class="sourceref"><a href="../source/webgl/glmatrix-cube-unlit.html">unlit cube</a></span>
example lets the user rotate the scene using the keyboard.  But using the mouse for rotation
gives the user much better control.  I have written two JavaScript classes,
<span class="classname">SimpleRotator</span> and <span class="classname">TrackballRotator</span>,
to implement two different styles of rotation-by-mouse.</p>


<p>The <span class="classname">SimpleRotator</span> class is defined in the file 
<span class="sourceref"><a href="../source/webgl/simple-rotator.js">webgl/simple-rotator.js</a></span>.  To use it on a web page, you need to include that file
in a <span class="tag">&lt;script&gt;</span> tag, and you need to create an object of type <span class="classname">SimpleRotator</span>:</p>


<pre>rotator = new SimpleRotator( canvas, callback, viewDistance );</pre>


<p class="noindent">The first parameter must be a <span class="word" data-term="DOM" data-definition="Document Object Model.  A specification for representing a web page (and other kinds of
structured document) as a tree-like data structure.  Can also refer to the data structure itself,
as in &quot;the DOM for this web page.&quot;  A web page can be modified dynamically by manipulating its
DOM, using the JavaScript programming language." title="Click for a definition of DOM.">DOM</span> <span class="tag">&lt;canvas&gt;</span> element.  It should be the
canvas where WebGL renders the scene. The <span class="classname">SimpleRotator</span> constructor
adds a listener
for mouse events to the canvas; it also handles touch events on a touchscreen. 
The second parameter to the constructor is optional.  
If it is defined, it must be a function.  The function is called, with no parameters, each time the rotation
changes.  Typically, the callback function is the function that renders the image in the
canvas.  The third parameter is also optional.  If defined, it must be a non-negative number.
It gives the distance of the viewer from the center of rotation.  The default value is zero,
which can be OK for an orthographic projection but is usually not correct.</p>


<p>A <span class="classname">SimpleRotator</span> keeps track of a viewing transformation that changes as
the user rotates the scene.  The most important function is <i>rotator.getViewMatrix</i>().
This function returns an array of 16 numbers representing the matrix for the viewing transformation 
in column-major order.  The matrix can be sent directly to the shader program using <i>gl.uniformMatrix4fv</i>,
or it can be used with functions from the <i>glMatrix</i> library as
the initial value of the modelview matrix.</p>


<p>The sample program <span class="sourceref"><a href="../source/webgl/cube-with-simple-rotator.html">webgl/cube-with-simple-rotator.html</a></span> is an example
of using a <span class="classname">SimpleRotator</span>.  The program uses a perspective projection defined by the
<i>glMatrix</i> function</p>


<pre>mat4.perspective(projection, Math.PI/8, 1, 8, 12);</pre>


<p class="noindent">The <i>viewDistance</i> for the rotator has to be between the <i>near</i> and <i>far</i>
distances in the projection.  Here, <i>near</i> is 8 and <i>far</i> is 12, and the
<i>viewDistance</i> can be set to 10.  The rotator is created during initialization using the statement</p>


<pre>rotator = new SimpleRotator(canvas, draw, 10);</pre>


<p class="noindent">In the <i>draw</i>() function, the viewing transformation is obtained from the rotator
before drawing the scene.  There is no modeling transformation in this program, so the
view matrix is also the modelview matrix.  That matrix
is multiplied by the projection matrix using a <i>glMatrix</i> function, and the
combined transformation matrix is sent to the shader program:</p>


<pre>let modelview = rotator.getViewMatrix();

mat4.multiply( modelviewProjection, projection, modelview );
gl.uniformMatrix4fv(u_modelviewProjection, false, modelviewProjection );</pre>


<p>That's really all that you need to know if you just want to use <span class="classname">SimpleRotator</span>
in your own programs.  I have also written an alternative rotator class,
<span class="classname">TrackballRotator</span>, which is defined in the JavaScript file
<span class="sourceref"><a href="../source/webgl/trackball-rotator.js">webgl/trackball-rotator.js</a></span>.  A <span class="classname">TrackballRotator</span>
can be used in the same way as a <span class="classname">SimpleRotator</span>.
The main difference is that a <span class="classname">TrackballRotator</span> allows completely
free rotation while a <span class="classname">SimpleRotator</span> has the constraint that
the <i>y</i>-axis will always remain vertical in the image.</p>


<p>The sample program <span class="sourceref"><a href="../source/webgl/cube-with-trackball-rotator.html">webgl/cube-with-trackball-rotator.html</a></span> uses a
<span class="classname">TrackballRotator</span>, but is otherwise identical to the <span class="classname">SimpleRotator</span>
example. The following demo lets you try out both types of rotator.  A <span class="classname">SimpleRotator</span>
is used for the cube on the left, and a <span class="classname">TrackballRotator</span> 
is used on the right:</p>
<div class="demo">
<noscript>
<h4 style="color:red; text-align:center">Demos require JavaScript.<br>Since JavaScript is not available,<br>the demo is not functional.</h4>
</noscript>
<p align="center">
<iframe src="../demos/c7/rotators.html" width="660" height="380"></iframe>
</p>
</div>


<p>By default, the center of rotation for either type of rotator is the origin, 
even if the origin is not at the center of the image.  However, you can change the 
center of rotation to be the point (<i>a,b,c</i>) by calling <i>rotation.setRotationCenter</i>([a,b,c]).  
The parameter must be an array of three numbers.  Typically, (<i>a,b,c</i>) would be the
point displayed at the center of the image (the point that would be the view reference
point in <i>gluLookAt</i>).</p>



<hr class="break">


<p>You don't need to understand the mathematics that is used to implement a
rotator.  In fact, <span class="classname">TrackballRotator</span> uses some advanced
techniques that I don't want to explain here.  However, <span class="classname">SimpleRotator</span>
is, well, more simple, and it's nice to know how it works. So, I will explain how the
view transformation is computed for a <span class="classname">SimpleRotator</span>.
Actually, it will be easier to think in terms of the corresponding modeling
transformation on the scene as a whole.  (Recall the equivalence between
modeling and viewing (<a href="../c3/s3.html#gl1geom.3.4">Subsection&nbsp;3.3.4</a>).)</p>


<p>The modeling transformation includes a rotation about the <i>y</i>-axis followed by a rotation about
the <i>x</i>-axis.  The sizes of the rotations change as the user drags the mouse.  
Left/right motion controls the rotation about the <i>y</i>-axis, while up/down motion
controls the rotation about the <i>x</i>-axis.  The rotation
about the <i>x</i>-axis is restricted to lie in the range &minus;85 to 85 degrees.  Note that
a rotation about the <i>y</i>-axis followed by a rotation about the <i>x</i>-axis always leaves the
<i>y</i>-axis pointing in a vertical direction when projected onto the screen.</p>


<p>Suppose the center of rotation is (<i>tx,ty,tz</i>) instead of (0,0,0).  To implement that,
before doing the rotations, we need to translate the scene to move the point (<i>tx,ty,tz</i>) 
to the origin.  We can do that with a translation by (<i>-tx,-ty,-tz</i>).
Then, after doing the rotation, we need to translate the origin back to the
point (<i>tx,ty,tz</i>).</p>


<p>Finally, if the <i>viewDistance</i> is not zero, we need to push the scene <i>viewDistance</i>
units away from the viewer.  We can do that with a translation by (0,0,<i>-viewDistance</i>).
If <i>d</i> is the view distance, <i>ry</i> is the rotation about the <i>y</i>-axis,
and <i>rx</i> is the rotation about the <i>x</i>-axis, then the sequence of modeling transformations
that we need to apply to the scene is as follows:</p>


<ol>

<li>Move the view center to the origin:  Translate by (<i>-tx,-ty,-tz</i>).</li>

<li>Rotate the scene by <i>ry</i> radians about the <i>y</i>-axis.</li>

<li>Rotate the scene by <i>rx</i> radians about the <i>x</i>-axis.</li>

<li>Move the origin back to view center:  Translate by (<i>tx,ty,tz</i>).</li>

<li>Move the scene away from the viewer: Translate by (0,0,<i>-d</i>).</li>

</ol>


<p class="noindent">Keeping in mind that modeling transformations are applied to objects in the opposite
of the order in which they occur in the code, the view matrix could be created by
the following <i>glMatrix</i> commands:</p>


<pre>viewmatrix = mat4.create();
mat4.translate(viewmatrix, viewmatrix, [0,0,-d]);
mat4.translate(viewmatrix, viewmatrix, [tx,ty,tz]);
mat4.rotateX(viewmatrix, viewmatrix, rx);
mat4.rotateY(viewmatrix, viewmatrix, ry);
mat4.translate(viewmatrix, viewmatrix, [-tx,-ty,-tz]);</pre>


<p class="noindent">In fact, in my code, I create the view matrix directly, based on the matrices for the individual
transformations.  The 4-by-4 matrices for rotation and translation are given in 
<a href="../c3/s5.html#gl1geom.5.2">Subsection&nbsp;3.5.2</a>.  The view matrix for a <span class="classname">SimpleRotator</span>
is the matrix product of five translation and rotation matrices:</p>


<p align="center">
<img src="matrices-for-simple-rotator.png" width="631" height="154" alt=""></p>


<p class="noindent">It's actually not too difficult to implement the multiplication. See the JavaScript file,
<span class="sourceref"><a href="../source/webgl/simple-rotator.js">webgl/simple-rotator.js</a></span>, if you are curious.</p>


</div>




</div>
<hr>
<div align="right">
<small>
        [  <a href="s2.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
	    <a href="../index.html">Main Index</a> ]
    </small>
</div>
</div>
</body>
<script src="../resource/glossary.js"></script>
</html>

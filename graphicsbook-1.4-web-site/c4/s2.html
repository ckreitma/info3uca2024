<!DOCTYPE html>
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Introduction to Computer Graphics, Section 4.2 -- Light and Material in OpenGL 1.1</title>
<link type="text/css" rel="stylesheet" href="../resource/graphicstext.css">
</head>
<body>
<div class="page">
<div align="right">
<small>
        [  <a href="s1.html">Previous Section</a> |
           <a href="s3.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
	    <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" cellpadding="5" border="2">
<tr>
<td>
<div align="center">
<b>Subsections</b>
<hr>
<small><a href="#gllight.2.1">Working with Material</a>
<br>
<a href="#gllight.2.2">Defining Normal Vectors</a>
<br>
<a href="#gllight.2.3">Working with Lights</a>
<br>
<a href="#gllight.2.4">Global Lighting Properties</a>
<br>
</small>
</div>
</td>
</tr>
</table>
<div class="content section">
<h3 class="section_title">Section 4.2</h3>
<h2 class="section_title">Light and Material in OpenGL 1.1</h2>
<hr class="break">


<p class="firstpar">In this section, we will see how to use light and material in OpenGL.
The functions that are discussed in this section are specific to
older versions of OpenGL, and will not carry over directly to
other graphics <span class="word" data-term="API" data-definition="Application Programming Interface.  A collection of related classes, functions,
constants, etc., for performing some task.  An API is an &quot;interface&quot; in the sense that it
can be used without understanding how its functionality is actually implemented." title="Click for a definition of API.">APIs</span>.  (But the general
ideas that they implement, which were covered in the
<a href="../c4/s1.html">previous section</a>
are more generally applicable.)</p>


<p>In OpenGL 1.1, the use of light and material must be enabled by calling
<i>glEnable</i>(<i>GL_LIGHTING</i>).  When lighting is disabled,
the color of a vertex is simply the current color as set by
<i>glColor*</i>.  When lighting is enabled, the color of a vertex
is computed using a mathematical formula that takes into account
the <span class="word" data-term="lighting" data-definition="Using light sources in a 3D scene, so that the appearance of objects in
the scene can be computed based on the interaction of light with the objects' material properties." title="Click for a definition of lighting.">lighting</span> of the scene and the <span class="word" data-term="material" data-definition="The properties of an object that determine how that object interacts
with light in the environment.  Material properties in OpenGL include, for example, diffuse
color, specular color, and shininess." title="Click for a definition of material.">material</span>
properties that have been assigned to the vertex, as discussed
in the previous section.
Now it's time to learn about the OpenGL commands that are used
to configure lighting and to assign materials to objects.</p>


<p>It is common for lighting to be turned on for <span class="word" data-term="rendering" data-definition="The process of producing a 2D image from a 3D scene description." title="Click for a definition of rendering.">rendering</span> 
some parts of a scene, but turned off for other parts.  We will say that 
some objects are "lit" while others aren't.  For example, wireframe
objects are usually drawn with lighting disabled, even if they
are part of a scene in which solid objects are lit.  But note that it is illegal to call
<i>glEnable</i> or <i>glDisable</i> between calls to <i>glBegin</i>
and <i>glEnd</i>, so it is not possible for part of a primitive
to be lit while another part <i>of the same primitive</i> is unlit.
(I should note that
when lighting is enabled, it is applied to point and line primitives 
as well as to polygons, even though it rarely makes sense to do so.)  Lighting
can be enabled and disabled by calling <i>glEnable</i>
and <i>glDisable</i> with parameter <i>GL_LIGHTING</i>.  Other light and
material settings don't have to be modified when lighting is turned off, 
since they are simply ignored when lighting is disabled. </p>


<p>To light a scene, in addition to enabling <i>GL_LIGHTING</i>,
you must configure at least one source of light.  For very basic
lighting, it often suffices to call</p>


<pre>glEnable(GL_LIGHT0);</pre>


<p class="noindent">This command turns on a <span class="word" data-term="directional light" data-definition="A light source whose light rays are parallel, all arriving from
the same direction.  Can be considered to be a light source at an effectively infinite distance.
Also called a &quot;sun,&quot; since the Sun is an example of a directional light source." title="Click for a definition of directional light.">directional light</span> that shines
from the direction of the viewer into the scene.  (Note that the last
character in <i>GL_LIGHT0</i> is a zero.)  Since it shines from the
direction of the viewer, it will illuminate everything that the user
can see.  The light is white, with no specular component; that is,
you will see the <span class="word" data-term="diffuse color" data-definition="A material property that represents the proportion of
incident light that is reflected diffusely from a surface." title="Click for a definition of diffuse color.">diffuse color</span> of objects, without
any <span class="word" data-term="specular highlight" data-definition="Illumination of a surface produced by specular reflection.
A specular highlight is seen at points on the surface where the angle from the surface to
the viewer is approximately equal to the angle from the surface to a light source." title="Click for a definition of specular highlight.">specular highlights</span>.
We will see later in this section how to change the characteristics
of this light source and how to configure additional sources.  But first,
we will consider materials and normal vectors.</p>


<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="gllight.2.1">4.2.1&nbsp;&nbsp;Working with Material</h3>


<p>Material properties are vertex <span class="word" data-term="attribute" data-definition="A property, such as color, of a graphical object.  An image can be specified
by the geometric shapes that it contains, together with their attributes." title="Click for a definition of attribute.">attributes</span> in
that same way that color is a vertex attribute.  That is, the OpenGL state
includes a current value for each of the material properties.  When a vertex
is generated by a call to one of the <i>glVertex*</i> functions, a copy of each
of the current material properties is stored, along with the vertex coordinates.
When a primitive that contains the vertex is rendered, the material properties 
that are associated with the vertex are used, along with information about lighting, 
to compute a color for the vertex.</p>


<p>This is complicated by the fact that polygons are two-sided, and the <span class="word" data-term="front face" data-definition="One of the two sides of a polygon in 3D.
A polygon has two sides. One is taken to be the front face, and the other is the back face.  In OpenGL, the
difference is determined by the order in which the vertices of the polygon are
enumerated.  The default is that, seen from the front, the vertices are enumerated
in counterclockwise order around the polygon." title="Click for a definition of front face.">front face</span>
and <span class="word" data-term="back face" data-definition="One of the two sides of a polygon in 3D.
A polygon has two sides. One is taken to be the front face, and the other is the back face.  In OpenGL, the
difference is determined by the order in which the vertices of the polygon are
enumerated.  The default is that, seen from the back, the vertices are enumerated
in clockwise order around the polygon." title="Click for a definition of back face.">back face</span> of a polygon can have different materials.  This means that,
in fact, two sets of material property values are stored for each vertex: the front
material and the back material.  (The back material isn't actually used unless you turn
on two-sided lighting, which will be discussed below.)</p>


<p>With all that in mind, we will look at functions for setting the current values of 
material properties.  For setting the <span class="word" data-term="ambient color" data-definition="A material property that represents the proportion of
ambient light in the environment that is reflected by a surface." title="Click for a definition of ambient color.">ambient</span>,
<span class="word" data-term="diffuse color" data-definition="A material property that represents the proportion of
incident light that is reflected diffusely from a surface." title="Click for a definition of diffuse color.">diffuse</span>, <span class="word" data-term="specular color" data-definition="A material property that represents the proportion of
incident light that is reflected specularly by a surface." title="Click for a definition of specular color.">specular</span>,
and <span class="word" data-term="emission color" data-definition="A material property that represents color that is intrinsic
to a surface, rather than coming from light from other sources that is reflected
by the surface.  Emission color can make the object look like it is glowing, but
it does not illuminate other objects.  Emission color is often called &quot;emissive color.&quot;" title="Click for a definition of emission color.">emission</span> material colors, the function is</p>


<pre>void glMaterialfv( int side, int property, float* valueArray )</pre>


<p class="noindent">The first parameter can be <i>GL_FRONT_AND_BACK</i>, <i>GL_FRONT</i>, or
<i>GL_BACK</i>.  It tells whether you are setting a material property value for the
front face, the back face, or both.  The second parameter tells which material property
is being set.  It can be <i>GL_AMBIENT</i>, <i>GL_DIFFUSE</i>, <i>GL_SPECULAR</i>,
<i>GL_EMISSION</i>, or <i>GL_AMBIENT_AND_DIFFUSE</i>.  Note that it is possible to
set the ambient and diffuse colors to the same value with one call to <i>glMaterialfv</i>
by using <i>GL_AMBIENT_AND_DIFFUSE</i> as the property name; this is the most common case.
The last parameter to <i>glMaterialfv</i> is an array containing four <span class="ptype">float</span> numbers.  The 
numbers give the <span class="word" data-term="RGBA color" data-definition="An RGB color&mdash;specified by red, green, and blue component values&mdash;together
with an alpha component.  The alpha component is most often take to specify the degree of transparency
of the color, with a maximal alpha value giving a fully opaque color." title="Click for a definition of RGBA color.">RGBA</span> color components as values in the range from 0.0 to
1.0; values outside this range are actually allowed, and will be used in lighting computations,
but such values are unusual.  Note that an alpha component is required, but it is
used only in the case of diffuse color:  When the vertex color is computed, its alpha component
is set equal to the alpha component of the diffuse material color.</p>


<p>The <span class="word" data-term="shininess" data-definition="A material property that determines the size and sharpness
of specular highlights.  Also called the &quot;specular exponent&quot; because of the way it is
used in lighting calculations.  In OpenGL, shininess is a number in the range 0 to 128." title="Click for a definition of shininess.">shininess</span> material property is a single  number rather than an
array, and there is a different function for setting its value (without the "v" at the
end of the name):</p>


<pre>void glMaterialf( int side, int property, float value )</pre>


<p class="noindent">Again, the <i>side</i> can be <i>GL_FRONT_AND_BACK</i>, <i>GL_FRONT</i>, or
<i>GL_BACK</i>.  The <i>property</i> <b>must</b> be <i>GL_SHININESS</i>.  And the
value is a <span class="ptype">float</span> in the range 0.0 to 128.0.</p>


<p>Compared to the large number of versions of <i>glColor*</i> and <i>glVertex*</i>,
the options for setting material are limited.  In particular, it is not possible to
set a material color without defining an array to contain the color component values.
Suppose for example that we want to set the ambient and diffuse colors to a bluish green.
In C, that might be done with</p>


<pre>float bgcolor[4] = { 0.0, 0.7, 0.5, 1.0 };
glMaterialfv( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, bgcolor );</pre>


<p class="noindent">With my JavaScript simulator for OpenGL, this would look like</p>


<pre>let bgcolor = [ 0.0, 0.7, 0.5, 1.0 ];
glMaterialfv( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, bgcolor );</pre>


<p class="noindent">And in the <span class="word" data-term="JOGL" data-definition="A Java implementation of OpenGL.  JOGL is very complicated, since it 
attempts to support all versions of OpenGL in one programming system.  JOGL integrates
seamlessly with Java's Swing and AWT graphics." title="Click for a definition of JOGL.">JOGL</span> API for Java, where methods with array
parameters have an additional parameter to give the starting index of the data
in the array, it becomes</p>


<pre>float[] bgcolor = { 0.0F, 0.7F, 0.5F, 1.0F };
gl.glMaterialfv(GL2.GL_FRONT_AND_BACK, GL2.GL_AMBIENT_AND_DIFFUSE, bgcolor, 0);</pre>


<p>In C, the third parameter is actually a pointer to <span class="ptype">float</span>, which allows
the flexibility of storing the values for several material properties in one array.
Suppose, for example, that we have a C array</p>


<pre>float gold[13] = { 0.24725, 0.1995, 0.0745, 1.0,      /* ambient */
                   0.75164, 0.60648, 0.22648, 1.0,    /* diffuse */
                   0.628281, 0.555802, 0.366065, 1.0, /* specular */
                   50.0                               /* shininess */
    };</pre>


<p class="noindent">where the first four numbers in the array specify an ambient color; the next
four, a diffuse color; the next four, a specular color; and the last number, a shininess
exponent.  This array can be used to set all the material properties:</p>


<pre>glMaterialfv( GL_FRONT_AND_BACK, GL_AMBIENT, gold );
glMaterialfv( GL_FRONT_AND_BACK, GL_DIFFUSE, &amp;gold[4] );
glMaterialfv( GL_FRONT_AND_BACK, GL_SPECULAR, &amp;gold[8] );
glMaterialf( GL_FRONT_AND_BACK, GL_SHININESS, gold[12] );</pre>


<p class="noindent">Note that the last function is <i>glMaterialf</i> rather than <i>glMaterialfv</i>,
and that its third parameter is a number rather than a pointer.
Something similar can be done in Java with	</p>



<pre>float[] gold = { 0.24725F, 0.1995F, 0.0745F, 1.0F,      /* ambient */
                 0.75164F, 0.60648F, 0.22648F, 1.0F,    /* diffuse */
                 0.628281F, 0.555802F, 0.366065F, 1.0F, /* specular */
                 50.0F                                  /* shininess */
    };
    
gl.glMaterialfv( GL2.GL_FRONT_AND_BACK, GL2.GL_AMBIENT, gold, 0 );
gl.glMaterialfv( GL2.GL_FRONT_AND_BACK, GL2.GL_DIFFUSE, gold, 4 );
gl.glMaterialfv( GL2.GL_FRONT_AND_BACK, GL2.GL_SPECULAR, gold, 8 );
gl.glMaterialf( GL2.GL_FRONT_AND_BACK, GL2.GL_SHININESS, gold[12] );</pre>


<p>The functions <i>glMaterialfv</i> and <i>glMaterialf</i> can be called
at any time, including between calls to <i>glBegin</i> and <i>glEnd</i>.
This means that different vertices of a primitive can have different
material properties.</p>


<hr class="break">


<p>So, maybe you like <i>glColor*</i> better than <i>glMaterialfv</i>?  If so,
you can use it to work with material as well as regular color.  If you
call</p>


<pre>glEnable( GL_COLOR_MATERIAL );</pre>


<p class="noindent">then some of the material color properties will track the color.  By default,
setting the color will also set the current front and back, ambient and diffuse material 
properties.  That is, for example, calling</p>


<pre>glColor3f( 1, 0, 0 );</pre>


<p class="noindent">will, if lighting is enabled, have the same effect as calling</p>


<pre>glMaterialfv( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, array );</pre>


<p class="noindent">where <i>array</i> contains the values 1, 0, 0, 1.
You can change the material property that tracks the color using</p>


<pre>void glColorMaterial( side, property );</pre>


<p class="noindent">where <i>side</i> can be <i>GL_FRONT_AND_BACK</i>, <i>GL_FRONT</i>, or
<i>GL_BACK</i>, and <i>property</i> can be <i>GL_AMBIENT</i>, <i>GL_DIFFUSE</i>, 
<i>GL_SPECULAR</i>, <i>GL_EMISSION</i>, or <i>GL_AMBIENT_AND_DIFFUSE</i>.
Neither <i>glEnable</i> nor <i>glColorMaterial</i> can be called between
calls to <i>glBegin</i> and <i>glEnd</i>, so all of the vertices of a primitive
must use the same setting.</p>


<p>Recall that when <i>glDrawArrays</i> or <i>glDrawElements</i> is used to
draw a primitive, the color values for the vertices of the primitive can be taken from a color
array, as specified using <i>glColorPointer</i>.  (See <a href="../c3/s4.html#gl1geom.4.2">Subsection&nbsp;3.4.2</a>.)
There are no similar arrays for material properties.  However, if a color
array is used while lighting is enabled, and if <i>GL_COLOR_MATERIAL</i> is also
enabled, then the color array will be used as the source for the values of
the material properties that are tracking the color.</p>



</div>




<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="gllight.2.2">4.2.2&nbsp;&nbsp;Defining Normal Vectors</h3>


<p>
<span class="word" data-term="normal vector" data-definition="A normal vector to a surface at a point on that 
surface is a vector that is perpendicular to the surface at that point.
Normal vectors to curves are defined similarly.  Normal vectors are important
for lighting calculations." title="Click for a definition of normal vector.">Normal vectors</span> are essential to lighting calculations.
(See <a href="../c4/s1.html#gl1light.1.3">Subsection&nbsp;4.1.3</a>.)
Like color and material, normal vectors are attributes of vertices.  The OpenGL state includes
a current normal vector, which is set using functions in the family <i>glNormal*</i>.  When a vertex is specified
with <i>glVertex*</i>, a copy of the current normal vector is saved as an attribute of the
vertex, and it is used as the normal vector for that vertex when the color of the vertex is
computed by the lighting equation.  Note that the normal vector for a vertex must be specified
<b>before</b> <i>glVertex*</i> is called for that vertex.</p>


<p>Functions in the family <i>glNormal*</i> include <i>glNormal3f</i>, <i>glNormal3d</i>,
<i>glNormal3fv</i>, and <i>glNormal3dv</i>.  As usual, a "v" means that the values are
in an array, "f" means that the values are <span class="ptype">floats</span>, and "d" means that
the values are <span class="ptype">doubles</span>.  (All normal vectors have three components).
Some examples:</p>


<pre>glNormal3f( 0, 0, 1 );  // (This is the default value.)
glNormal3d( 0.707, 0.707, 0.0 );
float normalArray[3] = { 0.577, 0.577, 0.577 };
glNormal3fv( normalArray );</pre>


<p class="noindent">For a polygon that is supposed to look flat, the same normal vector is used
for all of the vertices of the polygon.  For example, to draw one side of a cube,
say the "top" side, facing in the direction of the positive <i>y</i>-axis:</p>


<pre>glNormal3f( 0, 1, 0 ); // Points along positive y-axis
glBegin(GL_QUADS);
glVertex3fv(1,1,1);  
glVertex3fv(1,1,-1);
glVertex3fv(-1,1,-1);
glVertex3fv(-1,1,1);
glEnd();</pre>


<p class="noindent">Remember that the normal vector should point out of the front face of the polygon,
and that the front face is determined by the order in which the vertices are generated.
(You might think that the front face should be determined by the direction in which
the normal vector points, but that is <b>not</b> how its done.  If a normal vector for a vertex
points in the wrong direction, then lighting calculations will not give the correct color
for that vertex.)</p>


<p>When modeling a smooth surface, normal vectors should be chosen perpendicular to
the surface, rather than to the polygons that approximate the surface.  (See <a href="../c4/s1.html#gl1light.1.3">Subsection&nbsp;4.1.3</a>.)
Suppose that we want to draw the side of a cylinder with radius 1 and
height 2, where the center of the cylinder is at (0,0,0) and the axis lies
along the <i>z</i>-axis.  We can approximate the surface using a single 
triangle strip.  The top and bottom edges of the side of a cylinder are circles.
Vertices along the top edge will have coordinates
(<i>cos</i>(<i>a</i>),<i>sin</i>(<i>a</i>),1) and vertices along the bottom edge
will have coordinates (<i>cos</i>(<i>a</i>),<i>sin</i>(<i>a</i>),&minus;1), where <i>a</i>
is some angle. The normal vector
points in the same direction as the radius, but its <i>z</i>-coordinate is zero
since it points directly out from the side of the cylinder.  
So, the normal vector to the side of the cylinder at both of these
points will be (<i>cos</i>(<i>a</i>),<i>sin</i>(<i>a</i>),0).  Looking down the
<i>z</i>-axis at the top of the cylinder, it looks like this:</p>


<p align="center">
<img src="normal-to-cylinder.png" width="408" height="180" alt=""></p>


<p class="noindent">When we draw the side of the cylinder as a triangle strip, we have to generate
pairs of vertices on alternating edges.  The normal vector is the same for the two
vertices in the pair, but it is different for different pairs.  Here is the code:</p>


<pre>glBegin(GL_TRIANGLE_STRIP);
for (i = 0; i &lt;= 16; i++) {
   double angle = 2*3.14159/16 * i;  // i 16-ths of a full circle
   double x = cos(angle);
   double y = sin(angle);
   glNormal3f( x, y, 0 );  // Normal for both vertices at this angle.
   glVertex3f( x, y, 1 );  // Vertex on the top edge.
   glVertex3f( x, y, -1 ); // Vertex on the bottom edge.
}
glEnd();</pre>


<p>When we draw the top and bottom of the cylinder, on the other hand, we want a flat
polygon, with the normal vector pointing in the direction (0,0,1) for the top and
in the direction (0,0,&minus;1) for the bottom:</p>


<pre>glNormal3f( 0, 0, 1);
glBegin(GL_TRIANGLE_FAN);  // Draw the top, in the plane z = 1.
for (i = 0; i &lt;= 16; i++) {
   double angle = 2*3.14159/16 * i;
   double x = cos(angle);
   double y = sin(angle);
   glVertex3f( x, y, 1 );
}
glEnd();

glNormal3f( 0, 0, -1 );
glBegin(GL_TRIANGLE_FAN);  // Draw the bottom, in the plane z = -1
for (i = 16; i &gt;= 0; i--) {
   double angle = 2*3.14159/16 * i;
   double x = cos(angle);
   double y = sin(angle);
   glVertex3f( x, y, -1 );
}
glEnd();</pre>


<p class="noindent">Note that the vertices for the bottom are generated in the opposite order from
the vertices for the top, to account for the fact that the top and bottom face in
opposite directions.  As always, vertices need to be enumerated in counterclockwise order,
as seen from the front.</p>


<hr class="break">


<p>When drawing a primitive with <i>glDrawArrays</i> or <i>glDrawElements</i>,
it is possible to provide a different normal for each vertex by using a
normal array to hold the normal vectors.  The normal array works in the same
way as the color array and the vertex array.  To use one, you need to enable
the use of a normal array by calling</p>


<pre>glEnableClientState(GL_NORMAL_ARRAY);</pre>


<p class="noindent">The coordinates for the normal vectors must be stored in an array
(or in an <span class="word" data-term="nio buffer" data-definition="A Java object belonging to the class java.nio.Buffer or one of its
subclasses.  Nio buffers are similar to arrays, but they are optimized for input/output operations.
Nio buffers are used instead of arrays for certain purposes in Java's JOGL API for OpenGL." title="Click for a definition of nio buffer.">nio buffer</span> for <span class="word" data-term="JOGL" data-definition="A Java implementation of OpenGL.  JOGL is very complicated, since it 
attempts to support all versions of OpenGL in one programming system.  JOGL integrates
seamlessly with Java's Swing and AWT graphics." title="Click for a definition of JOGL.">JOGL</span>), and the location
of the data must be specified by calling</p>


<pre>glNormalPointer( type, stride, data );</pre>


<p class="noindent">The <i>type</i> specifies the type of values in the array. It can be
<i>GL_INT</i>, <i>GL_FLOAT</i>, or <i>GL_DOUBLE</i>.  The <i>stride</i> is an 
integer, which is usually&nbsp;0, meaning that there is no extra data in the array
between the normal vectors.  And <i>data</i> is the array (or buffer) that
holds the normal vectors, with three numbers for each normal.</p>


<p>With this setup, when <i>glDrawArrays</i> or <i>glDrawElements</i> is used to
draw a primitive, the normal vectors for the primitive will be pulled from the array.
Note that if <i>GL_NORMAL_ARRAY</i> is not enabled, then all of the normal vectors
for the primitive will be the same, and will be equal to the current normal vector
as set by <i>glNormal*</i>.</p>


<hr class="break">


<p>The lighting equation assumes that normal vectors are <span class="word" data-term="unit normal" data-definition="A normal vector of length one; that is, a unit vector that is
perpendicular to a curve or surface at a given point on the curve or surface." title="Click for a definition of unit normal.">unit normals</span>, 
that is, that they have length equal to one.  The default in OpenGL is to use normal vectors as
provided, even if they don't have length one, which will give incorrect results.  However,
if you call</p>


<pre>glEnable(GL_NORMALIZE);</pre>


<p class="noindent">then OpenGL will automatically convert every normal vector into a unit normal that 
points in the same direction.</p>


<p>Note that when a <span class="word" data-term="geometric transform" data-definition="A coordinate transformation; that is, a function that can
be applied to each of the points in a geometric object to produce a new object.  Common
transforms include scaling, rotation, and translation. " title="Click for a definition of geometric transform.">geometric transform</span> is
applied, normal vectors are transformed along with vertices; this is necessary because
a transformation can change the direction in which a surface is facing.  A scaling transformation
can change the length of a normal vector, so even if you provided unit normal vectors, they
will not be unit normals after a scaling transformation.  However, if you have enabled
<i>GL_NORMALIZE</i>, the transformed normals will automatically be converted back to unit
normals.  My recommendation is to <b>always</b> enable <i>GL_NORMALIZE</i> as part of
your OpenGL initialization.  The only exception would be if all of the normal vectors
that you provide are of length one and you do not apply any scaling transformations.
(Translations and rotations are OK, because they do not modify lengths.)</p>



</div>




<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="gllight.2.3">4.2.3&nbsp;&nbsp;Working with Lights</h3>


<p>OpenGL 1.1 supports at least eight light sources, which are identified by the
constants <i>GL_LIGHT0</i>, <i>GL_LIGHT1</i>, ..., <i>GL_LIGHT7</i>.  (An OpenGL
implementation might allow additional lights.)  Each light source can be configured
to be either a <span class="word" data-term="directional light" data-definition="A light source whose light rays are parallel, all arriving from
the same direction.  Can be considered to be a light source at an effectively infinite distance.
Also called a &quot;sun,&quot; since the Sun is an example of a directional light source." title="Click for a definition of directional light.">directional light</span> or a <span class="word" data-term="point light" data-definition="A light source whose light rays emanate from a single point.  Also
called a &quot;lamp,&quot; since a lamp approximates a point source of light. Also called a positional
light." title="Click for a definition of point light.">point light</span>,
and each light can have its own diffuse, specular, and ambient intensities.
(See <a href="../c4/s1.html#gl1light.1.2">Subsection&nbsp;4.1.2</a>.)</p>


<p>By default, all of the light sources are disabled.  To enable a light, call
<i>glEnable</i>(<i>light</i>), where <i>light</i> is one of the constants <i>GL_LIGHT0</i>,
<i>GL_LIGHT1</i>,&nbsp;....  However, just enabling a light does not give any illumination,
except in the case of <i>GL_LIGHT0</i>, since all light intensities are zero by 
default, with the single exception of the diffuse color of light number&nbsp;0.
To get any light from the other light sources, you need to change some of their
properties.  Light properties can be set using the functions</p>


<pre>void glLightfv( int light, int property, float* valueArray );</pre>


<p class="noindent">The first parameter is one of the constants <i>GL_LIGHT0</i>, <i>GL_LIGHT1</i>, ..., <i>GL_LIGHT7</i>.
It specifies which light is being configured.  The second parameter says which property of the
light is being set.  It can be <i>GL_DIFFUSE</i>, <i>GL_SPECULAR</i>, <i>GL_AMBIENT</i>,
or <i>GL_POSITION</i>.  The last parameter is an array that contains at least four <span class="ptype">float</span>
numbers, giving the value of the property.</p>


<p>For the color properties, the four numbers in the array specify the red,
green, blue, and alpha components of the color.  (The alpha component is not actually
used for anything.)  The values generally lie in the range 0.0 to 1.0, but can lie
outside that range; in fact, values larger than 1.0 are occasionally useful.
Remember that the diffuse and specular colors of a light tell how the light interacts
with the diffuse and specular material colors, and the ambient color is simply added
to the global ambient light when the light is enabled.  For example, to set up light
zero as a bluish light, with blue specular highlights, that adds a bit of blue to the
ambient light when it is turned on, you might use:</p>


<pre>float blue1[4] = { 0.4, 0.4, 0.6, 1 };
float blue2[4] = { 0, 0, 0.8, 1 };
float blue3[4] = { 0, 0, 0.15, 1 };
glLightfv( GL_LIGHT1, GL_DIFFUSE, blue1 );
glLightfv( GL_LIGHT1, GL_SPECULAR, blue2 );
glLightfv( GL_LIGHT1, GL_AMBIENT, blue3 );</pre>


<p class="noindent">It would likely take some experimentation to figure out exactly what values
to use in the arrays to get the effect that you want.</p>


<hr class="break">


<p>The <i>GL_POSITION</i> property of a light is quite a bit different.  It is used both
to set whether the light is a point light or a directional light, and to set its position or direction.
The property value for <i>GL_POSITION</i> is an array of four numbers (<i>x,y,z,w</i>),
of which at least one must be non-zero.  When the fourth number, <i>w</i>, 
is zero, then the light is directional and the point (<i>x,y,z</i>)
specifies  the direction of the light:  The light rays shine in the direction
of the line <b>from</b> the point (<i>x,y,z</i>) <b>towards</b> the origin.
This is related to <span class="word" data-term="homogeneous coordinates" data-definition="A way of representing n-dimensional vectors as
(n+1)-dimensional vectors where two (n+1) vectors represent the same n-dimensional vector
if they differ by a scalar multiple.  In 3D, for example, if w is not zero, then the
homogeneous coordinates (x,y,z,w) are equivalent to homogeneous coordinates 
(x/w,y/w,z/w,1), since they differ by
multiplication by the scalar w.  Both sets of coordinates represent the 3D vector (x/w,y/w,z/w)" title="Click for a definition of homogeneous coordinates.">homogeneous coordinates</span>: The source of the light
can be considered to be a point at infinity in the direction of 
(<i>x,y,z</i>).</p>


<p>On the other hand, if the fourth
number, <i>w</i>, is non-zero, then the light is a point light, and it is located
at the point (<i>x/w,&nbsp;y/w,&nbsp;z/w</i>).  Usually, <i>w</i> is&nbsp;1. The
value (<i>x,y,z,</i>1) gives a point light at (<i>x,y,z</i>).
Again, this is really homogeneous coordinates.</p>


<p>The default position for all lights is (0,0,1,0), representing
a directional light shining from the positive direction of the
<i>z</i>-axis, towards the negative direction of the <i>z</i>-axis.</p>


<p>One important and potentially confusing fact about lights is that
the position that is specified for a light is transformed by the
<span class="word" data-term="modelview transformation" data-definition="In OpenGL 1.1, a transform that combines the
modeling transform with the viewing transform.  That is, it is the composition of
the transformation from object coordinates to world coordinates and the transformation
from world coordinates to eye coordinates.  Because of the equivalence between
modeling and viewing transformations, world coordinates are not really meaningful for
OpenGL, and only the combined transformation is tracked." title="Click for a definition of modelview transformation.">modelview transformation</span> that is in effect <b>at the time the position is
set</b> using <i>glLightfv</i>.  Another way of saying this is that
the position is set in <span class="word" data-term="eye coordinates" data-definition="The coordinate system on 3D space defined by the viewer.
In eye coordinates in OpenGL 1.1, the viewer is located at the origin, looking in the
direction of the negative z-axis, with the positive y-axis pointing upwards, and the
positive x-axis pointing to the right. The modelview transformation maps objects into
the eye coordinate system, and the projection transform maps eye coordinates to clip coordinates." title="Click for a definition of eye coordinates.">eye coordinates</span>, not in 
<span class="word" data-term="world coordinates" data-definition="The coordinate system in which a scene is defined.  The image 
that is produced of the scene will show the contents of the world coordinate system that
lie within some view volume (for 3D) or view window (for 2D).  Objects are defined
in their own object coordinate system. Modeling transformations are then applied to place 
objects into the scene; that is, they transform object coordinates to world coordinates." title="Click for a definition of world coordinates.">world coordinates</span>.  Calling <i>glLightfv</i> with the
property set to <i>GL_POSITION</i> is very much like calling <i>glVertex*</i>.
The light position is transformed in the same way that the vertex coordinates
would be transformed.  For example,</p>


<pre>float position[4] = { 1,2,3,1 }
glLightfv(GL_LIGHT1, GL_POSITION, position);</pre>


<p class="noindent">puts the light in the same place as</p>


<pre>glTranslatef(1,2,3);
float position[4] = { 0,0,0,1 }
glLightfv(GL_LIGHT1, GL_POSITION, position);</pre>


<p class="noindent">For a directional light, the direction of the light is transformed
by the rotational part of the modelview transformation.</p>


<p>There are three basic ways to use light position.  It is easiest to think
in terms of potentially animated scenes.</p>


<p>
<b>First</b>, if the position is set before any modelview transformation is applied, then
the light is fixed with respect to the viewer.  For example, the default
light position is effectively set to (0,0,1,0) while the modelview transform
is the identity.  This means that it shines in the direction of the negative
<i>z</i>-axis, <i>in the coordinate system of the viewer</i>, where the
negative <i>z</i>-axis points into the screen.  Another way of saying 
this is that the light always shines from the direction of the viewer 
into the scene.  It's like the light is attached to the viewer.  If the
viewer moves about in the world, the light moves with the viewer.</p>


<p>
<b>Second</b>, if the position is set after the viewing transform
has been applied and before any modeling transform is applied, then
the position of the light is fixed in world coordinates.  It will not
move with the viewer, and it will not move with objects in the scene.
It's like the light is attached to the world.</p>


<p>
<b>Third</b>, if the position is set after a modeling transform has
been applied, then the light is subject to that modeling transformation.
This can be used to make a light that moves around in the scene as the 
modeling transformation changes.  If the light is subject to the same
modeling transformation as an object, then the light will move around
with that object, as if it is attached to the object.</p>



<p>The sample program <span class="sourceref"><a href="../source/glut/four-lights.c">glut/four-lights.c</a></span> or
<span class="sourceref"><a href="../source/jogl/FourLights.java">jogl/FourLights.java</a></span> uses multiple moving, colored
lights and lets you turn them on and off to see the effect. The demo below is a JavaScript version
of the same program. The program lets you see how light from
various sources combines to produce the visible color of an object.
The source code provides examples of configuring lights and using material
properties.</p>
<div class="demo">
<noscript>
<h4 style="color:red; text-align:center">Demos require JavaScript.<br>Since JavaScript is not available,<br>the demo is not functional.</h4>
</noscript>
<p align="center">
<iframe src="../demos/c4/four-lights-demo.html" width="620" height="470"></iframe>
</p>
</div>




</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="gllight.2.4">4.2.4&nbsp;&nbsp;Global Lighting Properties</h3>


<p>In addition to the properties of individual light sources, the OpenGL
lighting system uses several global properties. There are only three such 
properties in OpenGL 1.1.  One of them is the
global ambient light, which is ambient light that doesn't come from
the ambient color property of any light source.  Global ambient light
will be present in the environment even if all of <i>GL_LIGHT0</i>, 
<i>GL_LIGHT1</i>, ... are disabled.  By default, the global
ambient light is black (that is, its RGB components are all zero).  
The value can be changed using the function</p>


<pre>void glLightModelfv( int property, float* value )</pre>


<p class="noindent">where the <i>property</i> must be <i>GL_LIGHT_MODEL_AMBIENT</i> and
the <i>value</i> is an array containing four numbers giving the RGBA
color components of the global ambient light as numbers in the range
0.0 to 1.0.  In general, the global ambient light level should be quite low.
For example, in&nbsp;C:</p>


<pre>float ambientLevel[] = { 0.15, 0.15, 0.15, 1 };
glLightModelfv( GL_LIGHT_MODEL_AMBIENT, ambientLevel );</pre>


<p class="noindent">The alpha component of the color is usually set to 1, but it is not
used for anything.  For JOGL, as usual, there is an extra parameter to
specify the starting index of the data in the array, and the example
becomes:</p>


<pre>float[] ambientLevel = { 0.15F, 0.15F, 0.15F, 0 };
gl.glLightModelfv( GL2.GL_LIGHT_MODEL_AMBIENT, ambientLevel, 0 );</pre>


<p>The other two light model properties are options that can be
either off or on.  The properties are <i>GL_LIGHT_MODEL_TWO_SIDE</i>
and <i>GL_LIGHT_MODEL_LOCAL_VIEWER</i>. They can be set using the function</p>


<pre>void glLightModeli( int property, int value )</pre>


<p class="noindent">with a <i>value</i> equal to 0 or 1 to indicate whether the option
should be off or on.  You can use the symbolic constants
<i>GL_FALSE</i> and <i>GL_TRUE</i> for the value, but these
are just names for 0 and 1.</p>


<p>
<i>GL_LIGHT_MODEL_TWO_SIDE</i> is used to turn on <span class="word" data-term="two-sided lighting" data-definition="An option in OpenGL that allows the back face of a polygon to
have different material properties from the front face.  Also, when this option is on, the
normal vector that is used in lighting calculations for the back face is taken to be the
negative of the vector for the front face.  (The negative of a vector points in the opposite
direction.)" title="Click for a definition of two-sided lighting.">two-sided lighting</span>.
Recall that a polygon can have two sets of material properties, a
front material and a back material.  When two-sided lighting is off,
which is the default, only the front material is used; it is used 
for both the front face and the back face of the polygon.  Furthermore, the same normal vector is
used for both faces.  Since those vectors point&mdash;or at least are supposed
to point&mdash;out of the front face, they don't give the correct result for the back face.
In effect, the back face looks like it
is illuminated by light sources that lie in front of the polygon, but the back face
should be illuminated by the lights that lie behind the polygon.</p>


<p>On the other hand, when two-sided lighting is on, the back material is used on the back
face and  the direction of the normal vector is reversed when it is used
in lighting calculations for the back face.</p>


<p>You should use two-sided lighting whenever there are back faces that might
be visible in your scene.  (This will not be the case when your scene consists
of "solid" objects, where the back faces are hidden inside the solid.) With
two-sided lighting, you have the option of using the same material on both faces
or specifying different materials for the two faces.  For example, to put
a shiny purple material on front faces and a duller yellow material on back faces:</p>


<pre>glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, 1 ); // Turn on two-sided lighting.

float purple[] = { 0.6, 0, 0.6, 1 };
float yellow[] = { 0.6, 0.6, 0, 1 };
float white[] = { 0.4, 0.4, 0.4, 1 }; // For specular highlights.
float black[] = { 0, 0, 0, 1 };


glMaterialfv( GL_FRONT, GL_AMBIENT_AND_DIFFUSE, purple );  // front material
glMaterialfv( GL_FRONT, GL_SPECULAR, white );
glMaterialf( GL_FRONT, GL_SHININESS, 64 );

glMaterialfv( GL_BACK, GL_AMBIENT_AND_DIFFUSE, yellow );  // back material
glMaterialfv( GL_BACK, GL_SPECULAR, black );  // no specular highlights</pre>



<p class="noindent">This little demo shows
what these materials look like on a cylinder that has no top, so that you can see
the back faces on the inside surface:</p>
<div class="demo">
<noscript>
<h4 style="color:red; text-align:center">Demos require JavaScript.<br>Since JavaScript is not available,<br>the demo is not functional.</h4>
</noscript>
<p align="center">
<iframe src="../demos/c4/two-sided-lighting.html" width="380" height="450"></iframe>
</p>
</div>


<p>The third material property, <i>GL_LIGHT_MODEL_LOCAL_VIEWER</i>,  is much less 
important.  It has to do with the direction from a surface to the viewer in the
lighting equation.  By default, this direction is always taken to point directly
out of the screen, which is true for an <span class="word" data-term="orthographic projection" data-definition="A projection from 3D to 2D that simply discards the
z-coordinate.  It projects objects along lines that are orthogonal (perpendicular) to the
xy-plane.  In OpenGL 1.1, the view volume for an orthographic projection is a
rectangular solid." title="Click for a definition of orthographic projection.">orthographic projection</span> but
is not accurate for a <span class="word" data-term="perspective projection" data-definition="A projection from 3D to 2D that projects objects along
lines radiating out from a viewpoint.  A perspective projection attempts to simulate 
realistic viewing.  A perspective projection preserves perspective;
that is, objects that are farther from the viewpoint are smaller in the projection.
In OpenGL 1.1, the view volume for a perspective projection is a frustum, or truncated pyramid." title="Click for a definition of perspective projection.">perspective projection</span>.  If you turn on the
local viewer option, the true direction to the viewer is used.
In practice, the difference is usually not very noticeable.</p>


</div>






</div>
<hr>
<div align="right">
<small>
        [  <a href="s1.html">Previous Section</a> |
           <a href="s3.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
	    <a href="../index.html">Main Index</a> ]
    </small>
</div>
</div>
</body>
<script src="../resource/glossary.js"></script>
</html>

<!DOCTYPE html>
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Introduction to Computer Graphics, Section 6.1 -- The Programmable Pipeline</title>
<link type="text/css" rel="stylesheet" href="../resource/graphicstext.css">
</head>
<body>
<div class="page">
<div align="right">
<small>
        [  <a href="s2.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
	    <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" cellpadding="5" border="2">
<tr>
<td>
<div align="center">
<b>Subsections</b>
<hr>
<small><a href="#webgl.1.1">The WebGL Graphics Context</a>
<br>
<a href="#webgl.1.2">The Shader Program</a>
<br>
<a href="#webgl.1.3">Data Flow in the Pipeline</a>
<br>
<a href="#webgl.1.4">Values for Uniform Variables</a>
<br>
<a href="#webgl.1.5">Values for Attributes</a>
<br>
<a href="#webgl.1.6">Drawing a Primitive</a>
<br>
<a href="#webgl.1.7">WebGL 2.0: Vertex Array Objects</a>
<br>
<a href="#webgl.1.8">WebGL 2.0: Instanced Drawing</a>
<br>
</small>
</div>
</td>
</tr>
</table>
<div class="content section">
<h3 class="section_title">Section 6.1</h3>
<h2 class="section_title">The Programmable Pipeline</h2>
<hr class="break">


<p class="firstpar">OpenGL 1.1 uses a <span class="newword" data-term="fixed-function pipeline" data-definition="A graphics processing pipeline with a fixed set of processing
stages that cannot be modified by a programmer.  Data for an image passes through a sequence of
processing stages, with the image as the end product.  The sequence is called a &quot;pipeline.&quot;
With a fixed-function pipeline, the programmer can enable and disable stages and set options
that control the processing but cannot add to the functionality." title="Click for a definition of fixed-function pipeline.">fixed-function pipeline</span> for graphics processing.
Data is provided by a program and passes through a series of processing stages that ultimately
produce the pixel colors seen in the final image.  The program can enable and disable
some of the steps in the process, such as the <span class="word" data-term="depth test" data-definition="A solution to the hidden surface problem that involves keeping
track of the depth, or distance from the viewer, of the object currently visible at each
pixel in the image.  When a new object is drawn at a pixel, the depth of the new object
is compared to the depth of the current object to decide which one is closer to the viewer.
The advantage of the depth test is that objects can be rendered in any order.  A disadvantage
is that only a limited range of depths can be represented in the image." title="Click for a definition of depth test.">depth test</span> and <span class="word" data-term="lighting" data-definition="Using light sources in a 3D scene, so that the appearance of objects in
the scene can be computed based on the interaction of light with the objects' material properties." title="Click for a definition of lighting.">lighting</span>
calculations.  But there is no way for it to change what happens at each stage.  The functionality
is fixed.</p>


<p>OpenGL 2.0 introduced a <span class="newword" data-term="programmable pipeline" data-definition="A graphics processing pipeline in which some of the processing
stages can or must be implemented by programs.  Data for an image passes through a sequence of
processing stages, with the image as the end product.  The sequence is called a &quot;pipeline.&quot;
Programmable pipelines are used in modern GPUs to provide more flexibility and control to the
programmer.  The programs for a programmable pipeline are known as shaders and are written in 
a shader programming language such as GLSL." title="Click for a definition of programmable pipeline.">programmable pipeline</span>.  It became possible
for the programmer to replace certain stages in the pipeline with their own programs.
This gives the programmer complete control over what happens at that stage.  In OpenGL 2.0,
the programmability was optional; the complete fixed-function pipeline was still available
for programs that didn't need the flexibility of programmability.  WebGL uses a programmable
pipeline, and it is <b>mandatory</b>.  There is no way to use WebGL without writing
programs to implement part of the graphics processing pipeline.</p>


<p>The programs that are written as part of the pipeline are called <span class="newword" data-term="shader" data-definition="A program to be executed at some stage of the rendering pipeline.  OpenGL
shaders are written in the GLSL programming languages.  For WebGL, only vertex shaders
and fragment shaders are supported.  WebGPU also has compute shaders, which are used
in compute pipelines." title="Click for a definition of shader.">shaders</span>.
For WebGL, you need to write a <span class="newword" data-term="vertex shader" data-definition="A shader program that will be executed once for each vertex in a primitive.
A vertex shader must compute the vertex coordinates in the clip coordinate system.
It can also compute other properties, such as color." title="Click for a definition of vertex shader.">vertex shader</span>, which is called once for
each vertex in a <span class="word" data-term="geometric primitive" data-definition="Geometric objects in a graphics system, such as OpenGL, that are
not made up of simpler objects.  Examples in OpenGL include points, lines, and triangles,
but the set of available primitives depends on the graphics system.  (Note that as the term
is used in OpenGL, a single primitive can be made up of many points, line segments, or triangles.)" title="Click for a definition of geometric primitive.">primitive</span>, and a 
<span class="newword" data-term="fragment shader" data-definition="A shader program that will be executed once for
each pixel in a primitive.  A fragment shader must compute a color for the pixel,
or discard it.  Fragment shaders are also called pixel shaders." title="Click for a definition of fragment shader.">fragment shader</span>, which is called once for each
pixel in the primitive.  Aside from these two programmable stages,
the WebGL pipeline also contains several stages from the original fixed-function pipeline.
For example, the depth test is still part of the fixed functionality, and it can be enabled or
disabled in WebGL in the same way as in OpenGL&nbsp;1.1.</p>


<p>In this section, we will cover the basic structure of a WebGL program and how data
flows from the JavaScript side of the program into the graphics pipeline and through
the vertex and fragment shaders.</p>


<p>I should note that later versions of OpenGL have introduced
new programmable stages, in addition to the vertex and fragment shaders,
but they are not part of WebGL 1.0 or 2.0, and they are not covered in this book.</p>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl.1.1">6.1.1&nbsp;&nbsp;The WebGL Graphics Context</h3>


<p>To use WebGL, you need a WebGL graphics context.  The graphics context is a JavaScript object
whose methods implement the JavaScript side of the WebGL API.
WebGL draws its images in an <span class="word" data-term="HTML canvas" data-definition="A canvas element on a web page. The canvas appears as a rectangular area on the page.
The JavaScript programming language can use a canvas element as a drawing surface.  
HTML is a language for specifying the content of a web page.  JavaScript is the
programming language for web pages.  The canvas element supports a 2D graphics API.
In many browsers, it also supports the 3D graphics API, WebGL." title="Click for a definition of HTML canvas.">HTML canvas</span>, the same kind of <span class="tag">&lt;canvas&gt;</span> element
that is used for the 2D API that was covered in <a href="../c2/s6.html">Section&nbsp;2.6</a>. A graphics
context is associated with a particular canvas.  A graphics context for WebGL 1.0 can 
be obtained by calling the function
<i>canvas.getContext</i>("webgl"), where <i>canvas</i> is a <span class="word" data-term="DOM" data-definition="Document Object Model.  A specification for representing a web page (and other kinds of
structured document) as a tree-like data structure.  Can also refer to the data structure itself,
as in &quot;the DOM for this web page.&quot;  A web page can be modified dynamically by manipulating its
DOM, using the JavaScript programming language." title="Click for a definition of DOM.">DOM</span> object
representing the canvas.  For WebGL 2.0, you would simply use <i>canvas.getContext</i>("webgl2")
instead.  The return value of <i>getContext</i>() will be <i>null</i> if the context
cannot be created.  So, getting a WebGL graphics context often looks something like this:</p>


<pre>canvas = document.getElementById("webglcanvas");
gl = canvas.getContext("webgl");  // or maybe canvas.getContext("webgl2")
if ( ! gl ) {
    throw new Error("WebGL not supported; can't create graphics context.");
}</pre>


<p class="noindent">Here, the first line gets a reference to the HTML canvas that WebGL
will used throughout the program for drawing. The name <i>gl</i> for the
variable is up to you, but I will always use <i>gl</i> for the WebGL graphics 
context in my discussion.  This code assumes that the HTML source
for the web page includes a canvas element with id="webglcanvas", such as</p>


<pre>&lt;canvas width="800" height="600" id="webglcanvas"&gt;&lt;/canvas&gt;</pre>



<p>In the second line of the above code, 
<i>canvas.getContext</i>("webgl") will return <i>null</i>
if the web browser does not support "webgl" as a parameter to <i>getContext</i>.
Since <i>null</i> is considered to be <i>false</i> in JavaScript when used in
a <i>boolean</i> context, the third line tests whether the return value is <i>null</i>.
In that case, the code throws an error, which can be handled elsewhere, probably
by showing an error message to the user. Furthermore, the code will throw an exception if
the browser has no support at all for <span class="tag">&lt;canvas&gt;</span>.  My programs often
use an initialization function of the form</p>


<pre>function init() {
    try {
        canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl");  // or "webgl2"
        if ( ! gl ) {
            throw new Error("WebGL not supported.");
        }
    }
    catch (e) {
          .
          .  // report the error
          .
        return;
    }
    initGL();  // a function that initializes the WebGL graphics context
      .
      .  // other JavaScript initialization
      .
}</pre>


<p class="noindent">In this function, <i>canvas</i> and <i>gl</i> are global variables. And 
<i>initGL</i>() is a function defined elsewhere in the script 
that initializes the graphics context, including
creating and installing the shader programs.  The <i>init</i>() function should
be called when the page is loaded.  This can be arranged, for example, by
assigning "window.onload = init;" in the script.</p>


<p>Once the graphics context, <i>gl</i>, has been created, it can be used to call
functions in the WebGL API.  For example, the command for enabling the depth
test, which was written as <i>glEnable</i>(<i>GL_DEPTH_TEST</i>) in OpenGL,
becomes</p>


<pre>gl.enable( gl.DEPTH_TEST );</pre>


<p class="noindent">Note that both functions and constants in the API are referenced through the
graphics context.  The name "gl" for the graphics context is conventional, but remember that
it is just an ordinary JavaScript variable whose name is up to the programmer.</p>


<p>(Some very old browsers required <i>canvas.getContext</i>("experimental-webgl") to create
a WebGL 1.0 context.  This includes Internet Explorer&nbsp;11, but at this point,
no one should be using Internet Explorer.)</p>


</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl.1.2">6.1.2&nbsp;&nbsp;The Shader Program</h3>


<p>Drawing with WebGL requires a shader program, which consists of a vertex shader and
a fragment shader.  Shaders are written in some version of the <span class="word" data-term="GLSL" data-definition="OpenGL Shader Language, the programming language that is used to write
shader programs for use with OpenGL." title="Click for a definition of GLSL.">GLSL</span> programming language. 
WebGL 1.0 used GLSL ES 1.00, while WebGL 2.0 can use either GLSL ES 1.00 or GLSL ES 3.00.
The discussion here is about GLSL ES 1.00; I will explain some of the changes in the
3.00 version later.</p>
 

<p>GLSL is based on the C programming
language.  The vertex shader and fragment shader are separate programs, each with its own
<i>main</i>() function.  The two shaders are compiled separately and then "linked" to produce
a complete shader program.  The JavaScript API for WebGL includes functions for compiling
the shaders and then linking them.  To use the functions, the source code for the shaders
must be JavaScript strings.  Let's see how it works.  It takes three steps to create the
vertex shader.</p>


<pre>let vertexShader = gl.createShader( gl.VERTEX_SHADER );
gl.shaderSource( vertexShader, vertexShaderSource );
gl.compileShader( vertexShader );</pre>


<p class="noindent">The functions that are used here are part of the WebGL graphics context, <i>gl</i>,
and the parameter <i>vertexShaderSource</i> is the string that contains the source code for the
shader.  Errors in the source code will cause the compilation to fail silently.
You need to check for compilation errors by calling the function
</p>


<pre>gl.getShaderParameter( vertexShader, gl.COMPILE_STATUS )</pre>


<p class="noindent">which returns a boolean value to indicate whether the compilation succeeded. In
the event that an error occurred, you can retrieve an error message with</p>


<pre>gl.getShaderInfoLog( vertexShader )</pre>


<p class="noindent">which returns a string containing the result of the compilation.  (The exact format
of the string is not specified by the WebGL standard.  The string is meant to be
human-readable.)</p>


<p>The fragment shader can be created in a similar way.  With both shaders in hand,
you can create and link the program.  The shaders need to be "attached" to the
program object before linking.  The code takes the form:</p>


<pre>let prog = gl.createProgram();
gl.attachShader( prog, vertexShader );
gl.attachShader( prog, fragmentShader );
gl.linkProgram( prog );</pre>


<p>Even if the shaders have been successfully compiled, errors can occur when they
are linked into a complete program.  For example, the vertex and fragment shader
can share certain kinds of variable.  If the two programs declare such variables with the same name but
with different types, an error will occur at link time.   Checking for link errors
is similar to checking for compilation errors in the shaders.</p>


<p>The code for creating a shader program is always pretty much the same, so it is
convenient to pack it into a reusable function.  Here is the function that I use for
the examples in this chapter:</p>


<pre>/**
 * Creates a program for use in the WebGL context gl, and returns the
 * identifier for that program.  If an error occurs while compiling or
 * linking the program, an exception of type Error is thrown.  The error
 * string contains the compilation or linking error. 
 */
function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
   let vsh = gl.createShader( gl.VERTEX_SHADER );
   gl.shaderSource( vsh, vertexShaderSource );
   gl.compileShader( vsh );
   if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in vertex shader:  " + gl.getShaderInfoLog(vsh));
   }
   let fsh = gl.createShader( gl.FRAGMENT_SHADER );
   gl.shaderSource( fsh, fragmentShaderSource );
   gl.compileShader( fsh );
   if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in fragment shader:  " + gl.getShaderInfoLog(fsh));
   }
   let prog = gl.createProgram();
   gl.attachShader( prog, vsh );
   gl.attachShader( prog, fsh );
   gl.linkProgram( prog );
   if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
      throw new Error("Link error in program:  " + gl.getProgramInfoLog(prog));
   }
   return prog;
}</pre>


<p>There is one more step:  You have to tell the WebGL context to use the program.
If <i>prog</i> is a program identifier returned by the above function, this is done
by calling</p>


<pre>gl.useProgram( prog );</pre>


<p class="noindent">It is possible to create several shader programs.  You can then switch from one
program to another at any time by calling <i>gl.useProgram</i>, even in the middle of
rendering an image.  (<i>Three.js</i>, for example, uses a different program for each
type of <span class="classname">Material</span>.)</p>


<p>It is advisable to create any shader programs that you need as part of initialization.
Although <i>gl.useProgram</i> is a fast operation, compiling and linking are rather slow,
so it's better to avoid creating new programs while in the process of drawing an image.</p>


<p>Shaders and programs that are no longer needed can be deleted to free up the resources
they consume. Use the functions <i>gl.deleteShader</i>(<i>shader</i>) and
<i>gl.deleteProgram</i>(<i>program</i>).</p>


</div>


<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl.1.3">6.1.3&nbsp;&nbsp;Data Flow in the Pipeline</h3>


<p>The WebGL graphics pipeline renders an image.  The data that defines the image
comes from JavaScript.  As it passes through the pipeline, it is processed by 
the current vertex shader and fragment shader as well as by the fixed-function
stages of the pipeline.  You need to understand how data is placed by JavaScript
into the pipeline and how the data is processed as it passes through the pipeline.</p>


<p>The basic operation in WebGL is to draw a <span class="word" data-term="geometric primitive" data-definition="Geometric objects in a graphics system, such as OpenGL, that are
not made up of simpler objects.  Examples in OpenGL include points, lines, and triangles,
but the set of available primitives depends on the graphics system.  (Note that as the term
is used in OpenGL, a single primitive can be made up of many points, line segments, or triangles.)" title="Click for a definition of geometric primitive.">geometric primitive</span>.
WebGL uses just seven of the OpenGL primitives that were introduced in
<a href="../c3/s1.html#gl1geom.1.1">Subsection&nbsp;3.1.1</a>.  The primitives for drawing <span class="word" data-term="quad" data-definition="A quadrilateral, that is a four-sided figure in the plane.  OpenGL 1.1 has
the primitives GL_QUADS and GL_QUAD_STRIP for drawing quads, but it assumes without checking
that the vertices that are provided are in fact planar and define quadrilaterals that are convex." title="Click for a definition of quad.">quads</span>
and <span class="word" data-term="polygon" data-definition="A multi-sided shape lying in a plane and 
specified by a list of points, called its vertices, and made up
of the line segments from each point in the list to the next point in the list, plus a line
segment from the last point in the list to the first point.  All the points are required to
lie in the same plane.  Sometimes the term &quot;polygon&quot; includes the interior of the shape as well
as its boundary." title="Click for a definition of polygon.">polygons</span> have been removed.  The remaining primitives draw
points, line segments, and triangles.  In WegGL, the seven types of primitive are identified by
the constants <i>gl.POINTS</i>, <i>gl.LINES</i>, <i>gl.LINE_STRIP</i>, <i>gl.LINE_LOOP</i>,
<i>gl.TRIANGLES</i>, <i>gl.TRIANGLE_STRIP</i>, and <i>gl.TRIANGLE_FAN</i>, where 
<i>gl</i> is a WebGL graphics context.</p>


<p>When WebGL is used to draw a primitive, there are two general categories of data
that can be provided for the primitive.  The two kinds of data are referred to
as <span class="newword" data-term="attribute variable" data-definition="Variables that represent input to the vertex shader in a 
programmable graphics pipeline.  An attribute variable can take on a different value for 
each vertex in a primitive." title="Click for a definition of attribute variable.">attribute variables</span> 
(or just "attributes") and <span class="newword" data-term="uniform variable" data-definition="Variables that represent input to a shader program in a
programmable graphics pipeline.  A uniform variable has the same value at every vertex
and at every pixel of a primitive." title="Click for a definition of uniform variable.">uniform variables</span>
(or just "uniforms").  A primitive is defined by its type and by a list of <span class="word" data-term="vertex" data-definition="One of the points that define a geometric primitive, such as the
two endpoints of a line segment or the three vertices of a triangle.  (The plural is &quot;vertices.&quot;)
A vertex can be specified in a coordinate system by giving its x and y coordinates in
2D graphics, or its x, y, and z coordinates in 3D graphics." title="Click for a definition of vertex.">vertices</span>.
The difference between attributes and uniforms is that a uniform variable has a single value
that is the same for the entire primitive, while the value of an attribute variable can
be different for different vertices.</p>


<p>One attribute that should always be specified is the coordinates of the vertex.  
The vertex coordinates must be an attribute since each vertex
in a primitive will have its own set of coordinates.  Another possible attribute is color.
We have seen that OpenGL allows you to specify a different color for each vertex of
a primitive.  You can do the same thing in WebGL, and in that case the color will be an
attribute.  On the other hand, maybe you want the entire primitive to have the same,
"uniform" color; in that case, color can be a uniform variable.  Other quantities
that could be either attributes or uniforms, depending on your needs, include
<span class="word" data-term="normal vector" data-definition="A normal vector to a surface at a point on that 
surface is a vector that is perpendicular to the surface at that point.
Normal vectors to curves are defined similarly.  Normal vectors are important
for lighting calculations." title="Click for a definition of normal vector.">normal vectors</span> and <span class="word" data-term="material" data-definition="The properties of an object that determine how that object interacts
with light in the environment.  Material properties in OpenGL include, for example, diffuse
color, specular color, and shininess." title="Click for a definition of material.">material properties</span>.
<span class="word" data-term="texture coordinates" data-definition="Refers to the 2D coordinate system on a texture image, or to
similar coordinate systems for 1D and 3D textures.  Texture coordinates typically range from 0 to 1
both vertically and horizontally, with (0,0) at the lower left corner of the image.  The
term also refers to coordinates that are given for a surface and that are used to specify
how a texture image should be mapped to the surface." title="Click for a definition of texture coordinates.">Texture coordinates</span>, if they are used,
are almost certain to be an attribute, since it doesn't really make sense for
all the vertices in a primitive to have the same texture coordinates.  If a 
<span class="word" data-term="geometric transform" data-definition="A coordinate transformation; that is, a function that can
be applied to each of the points in a geometric object to produce a new object.  Common
transforms include scaling, rotation, and translation. " title="Click for a definition of geometric transform.">geometric transform</span> is to be applied to the primitive, it would naturally
be represented as a uniform variable.</p>


<p>It is important to understand, however, that WebGL does not come with <b>any</b>
predefined attributes, not even one for vertex coordinates.  In the programmable pipeline, the attributes and uniforms
that are used are entirely up to the programmer.  As far as WebGL is concerned,
attributes are just values that are passed into the vertex shader.  Uniforms
can be passed into the vertex shader, the fragment shader, or both.  WebGL does not
assign a meaning to the values.  The meaning is entirely determined by what the shaders
do with the values.  The set of attributes and uniforms that are used in drawing a
primitive is determined by the source code of the shaders that are in use
when the primitive is drawn.</p>


<p>To understand this, we need to look at what happens in the pipeline in a more detail.
When drawing a primitive, the JavaScript program specifies values for any attributes
and uniforms in the shader program.  For each attribute, it will specify an array of values,
one for each vertex.  For each uniform, it will specify a single value.  It must
send these values to the <span class="word" data-term="GPU" data-definition="Graphics Processing Unit, a computer hardware component that performs graphical
computations that create and manipulate images.  Operations such as drawing a line on the screen 
or rendering a 3D image are done in the GPU, which is optimized to perform such operations very
quickly." title="Click for a definition of GPU.">GPU</span> before drawing the primitive. 
The primitive can then be drawn by calling a single JavaScript function.  At that
point, the GPU takes over, and executes the shader programs. When drawing the primitive,
the GPU calls the vertex shader once for each vertex.  The attribute values for the vertex
that is to be processed 
are passed as input into the vertex shader.  Values of uniform variables are also passed 
to the vertex shader.  The way this works is that both attributes and uniforms are represented as
global variables in the vertex shader program.  Before calling the shader for a given vertex,
the GPU sets the values of those variables appropriately for that specific vertex.</p>


<p>As one of its outputs, the vertex shader must specify the coordinates of the vertex in 
the <span class="word" data-term="clip coordinates" data-definition="The default coordinate system in OpenGL.  The projection transform
maps the 3D scene to clip coordinates.  The rendered image will show the contents of the
cube in the clip coordinate system that contains x, y, and z values in the range from -1 to 1; anything
outside that range is &quot;clipped&quot; away." title="Click for a definition of clip coordinates.">clip coordinate system</span> (see <a href="../c3/s3.html#gl1geom.3.1">Subsection&nbsp;3.3.1</a>).
It does that by assigning a value to a special variable named <i>gl_Position</i>.
The position is often computed by applying a transformation to the
attribute that represents the coordinates in the <span class="word" data-term="object coordinates" data-definition="The coordinate system in which the coordinates for points in an 
object are originally specified, before they are transformed by any modeling or other transform that
will be applied to the object." title="Click for a definition of object coordinates.">object coordinate system</span>,
but exactly how the position is computed is up to the programmer.</p>


<p>After the positions of all the vertices in the primitive have been computed,
a fixed-function stage in the pipeline clips away the parts of the primitive whose coordinates
are outside the range of valid clip coordinates (&minus;1 to 1 along each coordinate axis).
The primitive is then <span class="word" data-term="rasterization" data-definition="The process of creating a raster image, that is one made of pixels,
from other data that specifies the content of the image.  For example, a vector graphics image
must be rasterized in order to be displayed on a computer screen." title="Click for a definition of rasterization.">rasterized</span>; that is, it is
determined which pixels lie inside the primitive. The GPU then calls the fragment shader once for
each pixel that lies in the primitive.  The fragment shader has access to uniform variables
(but not attributes).  It can also use a special variable named <i>gl_FragCoord</i>
that contains the clip coordinates of the pixel.  Pixel coordinates are computed
by <span class="word" data-term="interpolation" data-definition="Given values for some quantity at certain reference points, computing
a value for that quantity at other points by some kind of averaging applied to the values at
the reference points." title="Click for a definition of interpolation.">interpolating</span> the values of <i>gl_Position</i>
that were specified by the vertex shader.  The interpolation is done by another fixed-function 
stage that comes between the vertex shader and the fragment shader.
</p>


<p>Other quantities besides coordinates can work in much that same way.  That is, the vertex shader
computes a value for the quantity at each vertex of a primitive.  An interpolator takes the values
at the vertices and computes a value for each pixel in the primitive.  The value for a given
pixel is then input into the fragment shader when the shader is called to process that pixel.
For example, color in OpenGL follows this pattern: The color of an interior pixel of a primitive
is computed by interpolating the color at the vertices.  In GLSL, this
pattern is implemented using <span class="newword" data-term="varying variable" data-definition=" A variable that is used to communicate values from the
vertex shader to the fragment shader in the WebGL or OpenGL ES 2.0 graphics pipeline.
A varying variable is assigned a value in the vertex shader.  The value of the variable in
the fragment shader for a pixel in the primitive is obtained by interpolating the values 
from the vertices of the primitive.  (In newer versions of GLSL, which support additional
shader stages, the term &quot;varying variable&quot; is replaced by the more general terms &quot;in variable&quot; 
and &quot;out variable,&quot; which refer to variables that are used for input to or output from a shader.)" title="Click for a definition of varying variable.">varying variables</span>.</p>


<p>A varying variable is declared both in the vertex shader and in the fragment shader.
The vertex shader is responsible for assigning a value to the varying variable.  Each
vertex of a primitive can assign a different value to the variable.
The interpolator takes all the values produced by executing the vertex shader for 
each vertex of the primitive,  and it interpolates those values to produce a value for each
pixel.  When the fragment shader is executed for a given pixel, the value of the varying variable
is the interpolated value for that pixel.  The fragment shader can use the value in its
own computations.</p>


<p>Varying variables exist to communicate data from the vertex shader to the fragment shader.
They are defined in the shader source code.  They are not used or referred to in the
JavaScript side of the API.  Note that it is entirely up to the programmer to decide 
what varying variables to define and what to do with them.</p>


<p>We have almost gotten to the end of the pipeline.  After all that, the job of the
fragment shader is simply to specify a color for the pixel.  It does that by assigning
a value to a special variable named <i>gl_FragColor</i>.  That value will then
be used in the remaining fixed-function stages of the pipeline.</p>


<p>To summarize:  The JavaScript side of the program sends values for attributes and
uniform variables to the GPU and then issues a command to draw a primitive.  The GPU
executes the vertex shader once for each vertex.  The vertex shader can use the values
of attributes and uniforms. It assigns values to <i>gl_Position</i> and to any
varying variables that exist in the shader.  After clipping, rasterization, and interpolation, the
GPU executes the fragment shader once for each pixel in the primitive.  The fragment
shader can use the values of varying variables, uniform variables, and <i>gl_FragCoord</i>.
It computes a value for <i>gl_FragColor</i>.  This diagram summarizes the flow
of data:</p>


<p align="center">
<img src="webgl-dataflow.png" width="281" height="476" alt=""></p>


<p class="noindent">The diagram is not complete.  There are a few more special variables that I haven't mentioned.  
And there is the
important question of how <span class="word" data-term="texture" data-definition="Variation in some property from point-to-point on an object.  The most common type
is image texture.  When an image texture is applied to a surface, the surface color varies from
point to point." title="Click for a definition of texture.">textures</span> are used.  
But if you understand the diagram, you have a good
start on understanding WebGL.</p>


<hr class="break">


<p>
<b>For GLSL ES 3.00</b>, the same diagram applies, except that there is no
special variable <i>gl_FragColor</i>.  Instead, the fragment shader must define
its own output variable to represent the color.  In GLSL ES 1.00, 
the words "attribute" and "varying" are
used when declaring variables in the actual shader program source code.  In source code for the
3.00 version, attribute variables become "in" variables, since they are inputs
to the vertex shader, and varying variables become "out" variables in the
vertex shader and "in" variables in the fragment shader.  And the variable
<i>gl_FragColor</i> is replaced by an "out" variable in the fragment shader.
The use of the terms "in" and "out" are actually more appropriate to systems with
additional pipeline stages, where "out" variables from one stage can become "in" variables
to the next stage.  In any case, people still use the terms attribute and varying 
when discussing WebGL, even if it is using GLSL&nbsp;ES&nbsp;3.00.</p>


</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl.1.4">6.1.4&nbsp;&nbsp;Values for Uniform Variables</h3>


<p>It's time to start looking at some actual WebGL code. We will concentrate on the
JavaScript side first, but you need to know a little about GLSL.  GLSL has some
familiar basic data types: <span class="ptype">float</span>, <span class="ptype">int</span>, and
<span class="ptype">bool</span>.  But it also has some new predefined data types to represent
<span class="word" data-term="vector" data-definition="An element of a vector space.  Elements of a vector space can
be added and can be multiplied by constants. For computer graphics, a vector is
just a list or array containing two, three, or four numbers.  Vectors in that sense are often
used to represent points in 2D, 3D, or 4D space.  Properly, however, a vector represents a
quantity that has a length and a direction; a vector used in this way can be visualized
as an arrow." title="Click for a definition of vector.">vectors</span> and <span class="word" data-term="matrix" data-definition="A rectangular array of numbers.  A matrix can be represented as a
two-dimensional array, with numbers arranged in rows and columns.   An N-by-N matrix
represents a linear transformation from N-dimensional space to itself." title="Click for a definition of matrix.">matrices</span>.
For example, the data type <i>vec3</i> represents a vector in 3D.  The value of
a <i>vec3</i> variable is a list of three floating-point numbers.  Similarly,
there are data types <i>vec2</i> and <i>vec4</i> to represent 2D and 4D vectors.</p>


<p>Global variable declarations in a vertex shader can be marked as <i>attribute</i>,
<i>varying</i>, or <i>uniform</i> (or as <i>in</i>, <i>out</i>, or <i>uniform</i> in
GLSL ES 3.00, but again, we will stick to the 1.00 version for the time being). 
A variable declaration with none of these modifiers
defines a variable that is local to the vertex shader.  Global variables in a
fragment can optionally be <i>uniform</i> or <i>varying</i>, or they
can be declared without a modifier.  A varying variable should
be declared in both shaders, with the same name and type.  This allows the GLSL
compiler to determine what attribute, uniform, and varying variables are used in 
a shader program.</p>


<p>The JavaScript side of the program needs a way to refer to particular attributes
and uniform variables.  The function <i>gl.getUniformLocation</i>
can be used to get a reference to a uniform variable in a shader program, where <i>gl</i>
refers to the WebGL graphics context.  It takes
as parameters the identifier for the compiled program, which was returned by <i>gl.createProgram</i>,
and the name of the uniform variable in the shader source code.  For example,
if <i>prog</i> identifies a shader program that has a uniform variable named <i>color</i>, then
the location of the <i>color</i> variable can be obtained with the JavaScript statement
</p>


<pre>colorUniformLoc = gl.getUniformLocation( prog, "color" );</pre>


<p class="noindent">The location <i>colorUniformLoc</i> can then be used to set the value of the
uniform variable. For example:</p>


<pre>gl.uniform3f( colorUniformLoc, 1, 0, 0 );</pre>


<p class="noindent">The function <i>gl.uniform3f</i> is one of a family of functions that can be
referred to as a group as <i>gl.uniform*</i>.  This is similar to the family <i>glVertex*</i> in
OpenGL&nbsp;1.1.  The <i>*</i> represents a suffix that tells the number and type of
values that are provided for the variable.  In this case, <i>gl.uniform3f</i> takes
three floating point values, and it is appropriate for setting the value of a
uniform variable of type <i>vec3</i>.  The number of values can be 1, 2, 3, or 4.
The type can be "f" for floating point or "i" for integer.  (For a boolean uniform,
you should use <i>gl.uniform1i</i> and pass 0 to represent <i>false</i> or 
1 to represent <i>true</i>.)  If a "v" is added to the suffix, then the values
are passed in an array.  For example,</p>


<pre>gl.uniform3fv( colorUniformLoc, [ 1, 0, 0 ] );</pre>


<p class="noindent">There is another family of functions for setting the value of uniform matrix
variables.  We will get to that later.</p>


<p>The value of a uniform variable can be set any time after the shader
program has been compiled, and the value remains in effect until it is changed
by another call to <i>gl.uniform*</i>.</p>


<p>If the string that is passed as the second parameter <i>gl.getUniformLocation</i>
is not the name of a uniform variable in the shader programs, then the return value
is <i>null</i>. The return value can also be <i>null</i> if the uniform variable is declared in
the shader source code but is not "active" in the program. A variable that is declared but not
actually used is not active, and it does not get a location in the compiled program.
This has occasionally caused problems for me, when I commented out part of 
a shader program for debugging purposes, and accidentally made a variable inactive
by doing so.</p>


</div>




<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl.1.5">6.1.5&nbsp;&nbsp;Values for Attributes</h3>


<p>Turning now to attributes, the situation is more complicated, because an attribute can take a
different value for each vertex in a primitive.  The basic idea is that the complete set of data 
for the attribute is copied in a single operation from a JavaScript array into memory that is 
accessible to the GPU.  Unfortunately, setting things up to make that operation possible is nontrivial.</p>


<p>First of all, a regular JavaScript array is not suitable for this purpose.  For efficiency, we need
the data to be in a block of memory holding numerical values in successive memory locations, and
regular JavaScript arrays don't have that form.  To fix this problem, a new kind of array,
called <span class="word" data-term="typed array" data-definition="In JavaScript, an array type that is limited to holding numerical values
of a single type.  For example, the type Float32Array represents arrays that can hold 32-bit floating
point values, and Uint8Array arrays can hold only 8-bit integer values.  Such arrays are more efficient
than general JavaScript arrays for numerical calculations.  The were introduced into JavaScript
along with HTML canvas graphics and WebGL." title="Click for a definition of typed array.">typed arrays</span>, was introduced into JavaScript.  We encountered
typed arrays when working with <span class="word" data-term="three.js" data-definition="A JavaScript library for 3D graphics.  The library implements an
object-oriented scene graph API.  While it is used primarily with WebGL, three.js can
also render 3D scenes using the 2D canvas graphics API." title="Click for a definition of three.js.">three.js</span> in the <a href="../c5/index.html">Chapter&nbsp;5</a>.
There is a short introduction to typed arrays in <a href="../c5/s1.html#threejs.1.3">Subsection&nbsp;5.1.4</a>.
A typed array has a fixed length, 
which is assigned when it is created, and it can only hold numbers of a specified type.  
There are different kinds of typed array for different
kinds of numerical data.  For now we will use  <span class="classname">Float32Array</span>,
which holds 32-bit floating point numbers. Once you have a typed array, 
you can use it much like a regular array, but
when you assign any value to an element of a <span class="classname">Float32Array</span>, the value is
converted into a 32-bit floating point number.  If the value cannot be interpreted as a number,
it will be converted to <i>NaN</i>, the "not-a-number" value.</p>


<p>Before data can be transferred from JavaScript into an attribute variable, it must be placed
into a typed array.  When possible, for efficiency, you should work with typed arrays directly, rather than working
with regular JavaScript arrays and then copying the data into typed arrays.</p>


<hr class="break">


<p>For use in WebGL, the attribute data must be transferred into a <span class="word" data-term="VBO" data-definition="Vertex Buffer Object.  A block of memory that can hold the
coordinates or other attributes for a set of vertices.  A VBO can be stored on a GPU.
VBOs make it possible to send
such data to the GPU once and then reuse it several times.  In OpenGL, VBOs are
used with the functions glDrawArrays and glDrawElements." title="Click for a definition of VBO.">VBO</span> (vertex buffer 
object).  VBOs were introduced in OpenGL&nbsp;1.5 and were discussed briefly in <a href="../c3/s4.html#gl1geom.4.4">Subsection&nbsp;3.4.4</a>.
A&nbsp;VBO is a block of memory that is accessible to the GPU.  To use a VBO, you must first call
the function <i>gl.createBuffer</i>() to create it.  For example,</p>


<pre>colorBuffer = gl.createBuffer();</pre>


<p class="noindent">Before transferring data into the VBO, you must "bind" the VBO:</p>


<pre>gl.bindBuffer( gl.ARRAY_BUFFER, colorBuffer );</pre>


<p class="noindent">The first parameter to <i>gl.bindBuffer</i> is called the "target."  It specifies how the VBO will
be used. The target <i>gl.ARRAY_BUFFER</i> is used when the buffer is being used to store values
for an attribute.   Only one VBO at a time can be bound to a given target.</p>


<p>The function that transfers data into
a VBO doesn't mention the VBO&mdash;instead, it uses the VBO that is currently bound.
To copy data into that buffer, use <i>gl.bufferData</i>(). For example:</p>


<pre>gl.bufferData(gl.ARRAY_BUFFER, colorArray, gl.STATIC_DRAW);</pre>


<p class="noindent">The first parameter is, again, the target.  The data is transferred into the VBO that
is bound to that target.  The second parameter is the typed array that holds the data on the JavaScript side.
All the elements of the array are copied into the buffer, and the size of the array determines
the size of the buffer.  Note that this is a straightforward transfer of raw data bytes; WebGL
does not remember whether the data represents floats or ints or some other kind of data.</p>


<p>The third parameter to <i>gl.bufferData</i> is one of the constants
<i>gl.STATIC_DRAW</i>, <i>gl.STREAM_DRAW</i>, or <i>gl.DYNAMIC_DRAW</i>.  It is
a hint to WebGL about how the data will be used, and it helps WebGL to manage the
data in the most efficient way.  The value <i>gl.STATIC_DRAW</i> means that you intend to
use the data many times without changing it.  For example, if you will use the same
data throughout the program, you can load it into a buffer once, during initialization,
using <i>gl.STATIC_DRAW</i>.  WebGL will probably store the data on the graphics card
itself where it can be accessed most quickly by the graphics hardware.  The second value,
<i>gl.STEAM_DRAW</i>, is for data that will be used only once, or at most a few times.  (It can be
"streamed" to the card when it is needed.)  The value <i>gl.DYNAMIC_DRAW</i> is somewhere
between the other two values; it is meant for data that will be used multiple times, but
with modifications.</p>


<hr class="break">


<p>Getting attribute data into VBOs is only part of the story.  You also have to tell WebGL to
use the VBO as the source of values for the attribute.  To do so, first of all, you need
to know the location of the attribute in the shader program.  You can determine that
using <i>gl.getAttribLocation</i>.  For example,</p>


<pre>colorAttribLoc = gl.getAttribLocation(prog, "a_color");</pre>


<p class="noindent">This assumes that <i>prog</i> is the shader program and "a_color" is the name of the
attribute variable in the vertex shader.  This is entirely analogous to <i>gl.getUniformLocation</i>
(except that the return value is an integer, and is -1 if the requested attribute does not
exist or is not active).</p>


<p>Although an attribute usually takes different values at different vertices, it is possible to
use the same value at every vertex.  In fact, that is the default behavior.  The single attribute value
for all vertices can be
set using the family of functions <i>gl.vertexAttrib*</i>, which work similarly to
<i>gl.uniform*</i>.  In the more usual case, where you want to take the values of an attribute from a VBO,
you must enable the use of a VBO for that attribute.  This is done by calling</p>


<pre>gl.enableVertexAttribArray( colorAttribLoc );</pre>


<p class="noindent">where the parameter is the location of the attribute in the shader program, as returned
by a call to <i>gl.getAttribLocation</i>().   This command has nothing
to do with any particular VBO.  It just turns on the use of buffers for the specified attribute.
Often, it is reasonable to call this method just once, during initialization.
Use of data from the VBO can be turned off by calling
</p>


<pre>gl.disableVertexAttribArray( colorAttribLoc );</pre>


<p>Finally, before you draw a primitive that uses the attribute data from a VBO, you have to tell WebGL which buffer 
contains the data and how the bits in that buffer are to be interpreted.  This is done with 
<i>gl.vertexAttribPointer</i>().  The VBO must be bound to the <i>ARRAY_BUFFER</i> target when
this function is called.  For example,</p>


<pre>gl.bindBuffer( gl.ARRAY_BUFFER, colorBuffer );
gl.vertexAttribPointer( colorAttribLoc, 3, gl.FLOAT, false, 0, 0 );</pre>


<p class="noindent">Assuming that <i>colorBuffer</i> refers to the VBO and <i>colorAttribLoc</i> is
the location of the attribute, this tells WebGL to take values for
the attribute from that buffer.  Often, you will call <i>gl.bindBuffer</i>() just before calling
<i>gl.vertexAttribPointer</i>(), but that is not necessary if the desired buffer is already bound. </p>


<p>The first parameter to <i>gl.vertexAttribPointer</i> is the attribute location.  
The second is the number of values per vertex.  For example, if you are providing values 
for a <i>vec2</i>, the second parameter will be 2 and
you will provide two numbers per vertex; for a <i>vec3</i>, the second parameter would be 3;
for a <i>float</i>, it would be&nbsp;1.  The third parameter specifies the type of each value.
Here, <i>gl.FLOAT</i> indicates that each value is a 32-bit floating point number.  Other values
include <i>gl.BYTE</i>, <i>gl.UNSIGNED_BYTE</i>, <i>gl.UNSIGNED_SHORT</i>,
and <i>gl.SHORT</i> for integer values.  Note that in WebGL&nbsp;1.0, all attributes
are floating point values; if you provide integer values for an attribute, they will be
converted to floating point.  The parameter value should
match the data type in the buffer.  For example, if the data came from a <span class="classname">Float32Array</span>,
then the parameter should be <i>gl.FLOAT</i>.
For the last three parameters in a call to <i>gl.vertexAttribPointer</i>, 
I will always use <i>false</i>, 0, and&nbsp;0.
These parameters add flexibility that I won't need; you can look them up in the documentation
if you are interested.  (The <i>false</i> parameter has to do with how integer values are converted
into floating point values.)</p>


<p>
<b>In WebGL 2.0</b>, attribute variables can have integer type.  When
<i>gl.vertexAttribPointer</i>() is used to configure an attribute, the values provided for the attribute
will always be converted to floating point, so it is inappropriate for integer-valued attributes.
For use with integer-valued attributes, WebGL 2.0
introduces a new function, <i>gl.vertexAttribIPointer</i>() that works correctly with
integer data.</p>


<p>There is a lot to take in here.  Using a VBO to provide values for an attribute requires
six separate commands, and that is in addition to generating the data and placing it in
a typed array.  Here is the full set of commands:</p>


<pre>colorAttribLoc = gl.getAttribLocation( prog, "a_color" );
colorBuffer = gl.createBuffer();
gl.enableVertexAttribArray( colorAttribLoc );

gl.bindBuffer( gl.ARRAY_BUFFER, colorBuffer );
gl.vertexAttribPointer( colorAttribLoc, 3, gl.FLOAT, false, 0, 0 );
gl.bufferData( gl.ARRAY_BUFFER, colorArray, gl.STATIC_DRAW );</pre>


<p class="noindent">However, the six commands will not always occur at the same point in the JavaScript
code.  The first three commands are often done as part of initialization.  
<i>gl.bufferData</i> would be called whenever the data for the attribute needs to be changed;
it might be used just once during initialization, or it might be used whenever the data
needs to be modified.
<i>gl.bindBuffer</i> must be called before <i>gl.vertexAttribPointer</i>
or <i>gl.bufferData</i>, since it establishes the VBO that is used by those
two commands.  Remember that all of this must be done for every attribute that is
used in the shader program.</p>



</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl.1.6">6.1.6&nbsp;&nbsp;Drawing a Primitive</h3>


<p>After the shader program has been created and values have been set up for the uniform
variables and attributes, it takes just one more command to draw a primitive. One way to
do that is with the function <i>gl.drawArrays</i>:</p>


<pre>gl.drawArrays( primitiveType, startVertex, vertexCount );</pre>


<p class="noindent">The first parameter is one of the seven constants that identify WebGL primitive types,
such as <i>gl.TRIANGLES</i>, <i>gl.LINE_LOOP</i>, and <i>gl_POINTS</i>.  The second
and third parameters are integers that determine which subset of available vertices is used for the primitive.
Before calling <i>gl.drawArrays</i>, you will have placed attribute values for some number of vertices
into one or more VBOs.  When the primitive is rendered, the attribute values for enabled attributes are pulled from the
VBOs.  The <i>startVertex</i> is the starting vertex number of the data within the VBOs,
and <i>vertexCount</i> is the number of vertices in the primitive.  Often, <i>startVertex</i>
is zero, and <i>vertexCount</i> is the total number of vertices for which data is available.
For example, the command for drawing a single triangle might be</p>


<pre>gl.drawArrays( gl.TRIANGLES, 0, 3 );</pre>


<p>The use of the word "array" in <i>gl.drawArrays</i> and <i>gl.ARRAY_BUFFER</i> might be a little
confusing, since the data is stored in vertex buffer objects rather than in JavaScript arrays.
When <i>glDrawArrays</i> was first introduced in OpenGL&nbsp;1.1, it used ordinary arrays rather
than VBOs.  Starting with OpenGL 1.5, <i>glDrawArrays</i> could be used either with ordinary arrays
or VBOs.  In WebGL, support for ordinary arrays was dropped, and <i>gl.drawArrays</i> can only
work with VBOs, even though the name still refers to arrays.</p>


<p>We encountered the original version of <i>glDrawArrays</i> in <a href="../c3/s4.html#gl1geom.4.2">Subsection&nbsp;3.4.2</a>.
That section also introduced an alternative function for drawing primitives, <i>glDrawElements</i>,
which can be used for drawing indexed face sets.  A <i>gl.drawElements</i> function is also available
in WebGL.  With <i>gl.drawElements</i>, attribute data is not used in the order in which it occurs in 
the VBOs.  Instead, there is a separate list of indices that determines the order in which
the data is accessed.</p>


<p>To use <i>gl.drawElements</i>, an extra VBO is required to hold the list of indices.
When used for this purpose, the VBO must be bound to the target <i>gl.ELEMENT_ARRAY_BUFFER</i>
rather than <i>gl.ARRAY_BUFFER</i>.   The VBO will hold integer values, which can be of type 
<i>gl.UNSIGNED_BYTE</i> or <i>gl.UNSIGNED_SHORT</i> (or, for WebGL&nbsp;2.0, <i>gl.UNSIGNED_INT</i>).  
The values can be loaded from
a JavaScript typed array of type <span class="classname">Uint8Array</span>, for <i>gl.UNSIGNED_BYTE</i>,
or <span class="classname">Uint16Array</span>, for <i>gl.UNSIGNED_SHORT</i>.
Creating the VBO and filling it with data is again a multistep process.  For example,
</p>


<pre>elementBuffer = gl.createBuffer();
gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
let data = new Uint8Array( [ 2,0,3, 2,1,3, 1,4,3 ] );
gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, data, gl.STREAM_DRAW );</pre>


<p class="noindent">Assuming that the attribute data has also been loaded into VBOs, <i>gl.drawElements</i> can then be used
to draw the primitive.  A call to <i>gl.drawElements</i> takes the form</p>


<pre>gl.drawElements( primitiveType, count, dataType, startByte );</pre>


<p class="noindent">The VBO that contains the vertex indices must be bound to the <i>ELEMENT_ARRAY_BUFFER</i> target
when this function is called.
The first parameter to <i>gl.drawElements</i>
is a primitive type such as <i>gl.TRIANGLE_FAN</i>.  The <i>count</i>
is the number of vertices in the primitive.  The <i>dataType</i> specifies the type
of data that was loaded into the VBO; it will be either <i>gl.UNSIGNED_SHORT</i>
or <i>gl.UNSIGNED_BYTE</i>.  The <i>startByte</i> is the starting point in the VBO of
the data for the primitive; it is usually zero.  (Note that the starting point is given
in terms of bytes, not vertex numbers.) A typical example would be</p>


<pre>gl.drawElements( gl.TRIANGLES, 9, gl.UNSIGNED_BYTE, 0 );</pre>


<p>We will have occasion to use this function later.  If you find it confusing, you should
review <a href="../c3/s4.html#gl1geom.4.2">Subsection&nbsp;3.4.2</a>.  The situation is much the same in WebGL as it was
in OpenGL&nbsp;1.1.</p>


</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl.1.7">6.1.7&nbsp;&nbsp;WebGL 2.0: Vertex Array Objects</h3>


<p>The large number of functions needed to work with attributes can seem excessive.
The situation is worse in a program that draws several different objects.  Each object can
require its own buffers and its own settings for attribute pointers.
Before drawing each object, it would be necessary to call <i>gl.bindBuffer</i>()
and <i>gl.vertexAttribPointer</i>() for each attribute. A typical 3D graphics program
would use attributes for vertex coordinates, normal vectors, material properties, and
texture coordinates.  So, there would be a lot of function calls for each object.</p>


<p>To help with this situation, WebGL 2.0 introduced <span class="newword" data-term="VAO" data-definition="Vertex Array Object.  In WebGL 2.0, a region of memory, typically on the graphics card,
that holds a collection of attribute settings such as enabled state and values of vertex attribute pointers.
All of the settings can then be selected simply by binding the VAO." title="Click for a definition of VAO.">Vertex Array Objects</span> (VAOs).
A VAO is a section of memory, typically stored on the graphics card.  It holds settings
that are used by rendering functions such as <i>gl.drawArrays</i>().  This includes the 
enabled state of each attribute, references to the buffers used for the attribute data,
and the values of all properties that are set by calling <i>gl.vertexAttribPointer</i>().
It also includes the settings and a reference to the buffer used by <i>gl.drawElements()</i>,
as well as the attribute divisors that are discussed in the next subsection.</p>


<p>WebGL 2.0 has a default VAO, which it uses when no other VAO has been selected.
To use an alternative VAO, you first have to create it, by calling <i>gl.createVertexArray</i>():</p>


<pre>vao = gl.createVertexArray();</pre>


<p class="noindent">The return value, <i>vao</i>, is an identifier for the VAO that has been created.
In the new VAO, all properties have their default values.  In particular, all vertex
attributes are disabled and have no associated buffers.
To actually use a VAO, you need to bind it:</p>


<pre>gl.bindVertexArray(vao);</pre>


<p class="noindent">Functions that affect or use attributes apply to the VAO that is currently bound.
For example, the settings in a call to <i>gl.vertexAttribPointer</i>() are stored
in the current VAO.  And a call to <i>gl.drawArrays</i>() gets all the data that
it needs to draw a primitive from the current VAO.  A program can switch from one
VAO to another at any time simply by calling <i>gl.bindVertexArray</i>.  To go 
back to using the default VAO, a program can call <i>gl.bindVertexArray</i>(0).</p>


<p>The idea is that a program that draws several objects can use a different
VAO for each object.  The VAO for an object must be bound when the settings for
the object are configured.
But before drawing the object, the program simply needs to
bind the VAO for that object.  That single function call replaces a potentially
a large number of function calls that would be needed to restore the appropriate settings for each attribute
individually.  The advantage is more than just a more nicely organized program&mdash;it
is also much more efficient, since only one command needs to be sent to the GPU
to configure all of the attributes.</p>


<p>The sample WebGL 2.0 program <span class="sourceref"><a href="../source/webgl/VAO-test-webgl2.html">webgl/VAO-test-webgl2.html</a></span> uses a
different VAO for each of six different objects.  That program uses many
techniques that we have not yet covered, but you can look at the
<i>drawModel</i>() function to see how it uses VAOs and VBOs.</p>


</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="webgl.1.8">6.1.8&nbsp;&nbsp;WebGL 2.0: Instanced Drawing</h3>


<p>It's common for a scene to contain multiple copies of the same
primitive (that is, using the same vertex coordinates), but with
different transformations, colors, or other properties for each
copy. WebGL&nbsp;2.0 makes it possible to draw all those copies
with a single function call.  This is called <span class="newword" data-term="instanced drawing" data-definition="The ability to render multiple versions of a primitive
with a single function call.  Each copy can have its own values for certain attributes, such as
color or transformation." title="Click for a definition of instanced drawing.">instanced drawing</span>
or instancing, and the individual copies of the primitive are called instances.
The functions that use instanced drawing are
<i>gl.drawArraysInstanced</i>() and <i>gl.drawElementsInstanced</i>().</p>


<p>Instanced properties&mdash;the properties that vary from one instance to another&mdash;are things
that would likely be uniform variables when drawing each instance separately.
That is, each instance gets just one value of the property that applies
to all the vertices of the instance.  Nevertheless, the properties
are represented by attribute variables in the shader program, not uniform
variables, and they are configured as attributes.</p>


<p>To specify that an attribute is an instanced property, you just need to
specify a "divisor" for that attribute.  This is done by calling
<i>gl.vertexAttribDivisor</i>:</p>


<pre>g.vertexAttribDivisor( attribID, divisor );</pre>


<p class="noindent">Here, <i>attribID</i> is the identifier for the attribute, as returned by
<i>gl.getAttribLocation</i>().  The <i>divisor</i> is a non-negative integer.
Passing zero as the divisor will turn off instancing for the attribute.
If <i>divisor</i> is positive, then each value of the attribute will apply
to that many instances.  For example, if <i>divisor</i> is 3, then the
first entry in the attribute value array applies to the first, second, and
third instances; the second value in the array applies to the fourth, fifth,
and sixth instances; and so on.  In practice, the value of <i>divisor</i>
is usually one, meaning that each instance has its own entry in the
attribute value array.</p>


<p>For an instanced property, in addition to setting the divisor, it is still
necessary to enable the attribute, load data for it into a VBO, and
configure it with <i>gl.vertexAttribPointer</i>.  And, of course, it is
necessary to draw the primitive using <i>gl.drawArraysInstanced</i>()
or <i>gl.drawElementsInstanced</i>(), and not with <i>gl.drawArrays</i>()
or <i>gl.drawElements()</i>.</p>


<p>The sample WebGL 2.0 program <span class="sourceref"><a href="../source/webgl/instancing-test-webgl2.html">webgl/instancing-test-webgl2.html</a></span> 
is an example of instanced drawing.  (Again, there is a lot in the program
that you won't understand until we have covered more of WebGL).  The
program draws 30 colored disks, where a disk is approximated by
a primitive of type <i>gl.TRIANGLE_FAN</i>.  Three attributes are used:
an attribute that holds the coordinates of the vertices, an
instanced attribute that holds the colors for the disks, and
an instanced attribute that holds a different translation for
each disk.</p>


<p>Another point of interest in the program is its used of vertex buffer objects.
The disks can be animated.  The disks move, but their colors don't change.
Since the colors don't change, the color values for the disks are loaded
into a VBO once, during program initialization.  The usage parameter in
<i>gl.bufferData</i> is set to <i>gl.STATIC_DRAW</i> because the 
data will not be modified.  However, because the disks are moving, the values for
the translations of the disks have to change in each frame.
So, new data is loaded into the corresponding VBO for each frame, with
usage <i>gl.STREAM_DRAW</i> because the data that is being loaded will
only be used once.</p>


<p>Finally, I should note that VAOs and instancing require WebGL 2.0,
but the same functionality is available in many implementations of 
WebGL 1.0 as optional extensions.  Webgl extensions will be discussed
in <a href="../c7/s5.html">Section&nbsp;7.5</a>.</p>



</div>






</div>
<hr>
<div align="right">
<small>
        [  <a href="s2.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
	    <a href="../index.html">Main Index</a> ]
    </small>
</div>
</div>
</body>
<script src="../resource/glossary.js"></script>
</html>
